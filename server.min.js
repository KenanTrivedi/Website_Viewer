require("dotenv").config();
const express = require("express");
const createCsvWriter = require("csv-writer").createObjectCsvWriter;
const mongoose = require("mongoose");
const bodyParser = require("body-parser");
const path = require("path");
const jwt = require("jsonwebtoken");
const app = express();

mongoose.set("strictQuery", false);
app.use(bodyParser.json());
app.use(express.static("docs"));

// --------------------------------------------------------------------
// Connect to MongoDB
const mongoURI =
  process.env.MONGODB_URI || "mongodb://localhost:27017/surveyDB";
mongoose
  .connect(mongoURI)
  .then(() => console.log("MongoDB connected"))
  .catch((err) => console.error("MongoDB connection error:", err));

// --------------------------------------------------------------------
// CODE SCHEMA
const codeSchema = new mongoose.Schema({ code: String });
const Code = mongoose.model("Code", codeSchema, "codes");

// --------------------------------------------------------------------
// USERDATA SCHEMA  (userId is a STRING, unique)
const userDataSchema = new mongoose.Schema({
  userId: { type: String, required: true, unique: true },
  // data: { type: Object, default: {} }, // REMOVED: Redundant field
  courses: { type: [String], default: [] },
  isComplete: { type: Boolean, default: false },
  timeStamps: {
    t1: { type: Date, default: null },
    t2: { type: Date, default: null },
    t3: { type: Date, default: null },
  },
  initialScores: { type: Object, default: {} },
  updatedScores: { type: Object, default: {} },
  followUpScores: { type: Object, default: {} },
  initialResponses: { type: Object, default: {} },
  updatedResponses: { type: Object, default: {} },
  followUpResponses: { type: Object, default: {} },
  currentSection: { type: Number, default: 0 },
  datenschutzConsent: { type: Boolean, default: false },
  unterschrift: { type: String, default: "" },
  attemptNumber: { type: Number, default: 1 },
  openEndedResponses: { type: Object, default: {} },
  preSurveyResponses: { type: Object, default: {} }, // Added for pre-survey questions
});
const UserData = mongoose.model("UserData", userDataSchema, "userdatas");

// --------------------------------------------------------------------
// Admin login constants
const JWT_SECRET = process.env.JWT_SECRET || "your-secret-key";
const DASHBOARD_USER_ID = process.env.DASHBOARD_USER_ID || "admin";
const DASHBOARD_PASSWORD = process.env.DASHBOARD_PASSWORD || "password";

// --------------------------------------------------------------------
// Load the surveyData
const surveyData = require("./docs/js/survey-data.min.js");

// --------------------------------------------------------------------
// A simple helper for protecting dashboard routes
function authenticate(req, res, next) {
  const authHeader = req.headers.authorization;
  const token = authHeader?.split(" ")[1];
  if (!token) {
    return res.status(401).json({ error: "Unauthorized" });
  }
  jwt.verify(token, JWT_SECRET, (err, decoded) => {
    if (err) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    req.userId = decoded.userId;
    next();
  });
}

// --------------------------------------------------------------------
// Simple function to calculate T1 vs T2/T3 scale scores
function calculateCategoryScores(user, survey, attemptNumber) {
  const result = { t1: {}, latest: {} };

  survey.forEach((section, sIndex) => {
    // skip personal info and conclusion
    if (
      section.title !== "Persönliche Angaben" &&
      section.title !== "Abschluss"
    ) {
      let sumT1 = 0;
      let sumLatest = 0; // This will hold sum for T1, T2, or T3
      let questionCount = 0;

      section.questions.forEach((question, qIndex) => {
        if (question.type === "scale") {
          questionCount++;
          const key = `q${sIndex}_${qIndex}`;

          if (user.initialResponses?.[key]) {
            const valT1 = parseInt(user.initialResponses[key], 10);
            if (!isNaN(valT1)) sumT1 += valT1;
          }

          // Calculate based on attemptNumber
          if (attemptNumber === 1 && user.initialResponses?.[key]) {
            const val = parseInt(user.initialResponses[key], 10);
            if (!isNaN(val)) sumLatest += val; // Use sumLatest for all
          } else if (attemptNumber === 2 && user.updatedResponses?.[key]) {
            const val = parseInt(user.updatedResponses[key], 10);
            if (!isNaN(val)) sumLatest += val;
          } else if (attemptNumber === 3 && user.followUpResponses?.[key]) {
            const val = parseInt(user.followUpResponses[key], 10);
            if (!isNaN(val)) sumLatest += val;
          }
        }
      });

      if (questionCount > 0) {
        const max = 6 * questionCount; // scale 0..6
        result.t1[section.title] = Math.round((sumT1 / max) * 100);
        result.latest[section.title] = Math.round((sumLatest / max) * 100); // Use sumLatest
      }
    }
  });

  // compute average
  function avg(scoresObj) {
    const vals = Object.values(scoresObj);
    if (!vals.length) return 0;
    return Math.round(vals.reduce((a, b) => a + b, 0) / vals.length);
  }
  result.t1.overall = avg(result.t1);
  result.latest.overall = avg(result.latest);

  result.metadata = {
    maxScorePerQuestion: 6,
    scoreType: "percentage",
    categories: Object.keys(result.t1).filter((c) => c !== "overall"),
    t1Label: "Initial Assessment",
    latestLabel: `Attempt ${attemptNumber || 1}`, // Use attemptNumber
  };
  return result;
}

// --------------------------------------------------------------------
// 1)  Reset user data except T1
app.post("/api/reset-user-data", async (req, res) => {
  const { userId } = req.body;
  if (!userId) {
    return res.status(400).json({ message: "userId is required." });
  }
  try {
    const user = await UserData.findOne({ userId });
    if (!user) {
      return res.status(404).json({ message: "User not found." });
    }
    // Keep only T1 subset
    // const t1Subset = {   //REMOVED
    //   q0_0: user.data.q0_0,
    //   q0_1: user.data.q0_1,
    //   q0_2: user.data.q0_2,
    //   q0_3: user.data.q0_3,
    //   q0_4: user.data.q0_4,
    //   q0_5: user.data.q0_5,
    //   q0_6: user.data.q0_6,
    // };
    // user.data = t1Subset;  //REMOVED
    user.updatedResponses = {};
    user.updatedScores = {};
    user.followUpResponses = {};
    user.followUpScores = {};
    user.isComplete = false;
    user.currentSection = 0;
    await user.save();
    return res.status(200).json({ message: "Survey data reset successfully." });
  } catch (err) {
    console.error("Error resetting user data:", err);
    return res.status(500).json({ message: "Error resetting user data." });
  }
});

// --------------------------------------------------------------------
// 2)  Register a new code
app.post("/register", async (req, res) => {
  const { code } = req.body;
  if (!code) {
    return res.status(400).json({ message: "Code is required" });
  }
  try {
    const uppercaseCode = code.toUpperCase();
    const existingCode = await Code.findOne({ code: uppercaseCode });
    if (existingCode) {
      return res.status(400).json({
        message:
          "Dieser Code existiert bereits. Bitte verwenden Sie einen anderen Code.",
        isDuplicateCode: true,
      });
    }
    const newCode = new Code({ code: uppercaseCode });
    await newCode.save();

    return res.status(201).json({ message: "Code saved", userId: newCode._id });
  } catch (err) {
    console.error("Failed to save code:", err);
    return res
      .status(500)
      .json({ message: "Error saving code: " + err.message });
  }
});

// --------------------------------------------------------------------
// 3)  LOGIN with T1/T2/T3 logic (CREATES doc if not found)
app.post("/login", async (req, res) => {
  const { code, courses, startNewAttempt, attemptType } = req.body;
  try {
    const uppercaseCode = code.toUpperCase();
    const codeDoc = await Code.findOne({ code: uppercaseCode });
    if (!codeDoc) {
      return res.status(400).json({ message: "Ungültiger Code" });
    }
    const stringUserId = codeDoc._id.toString();
    let user = await UserData.findOne({ userId: stringUserId });

    if (user) {
      // doc already exists
      if (startNewAttempt) {
        // they want T2 or T3 or reset T1
        if (attemptType === "T2") {
          user.attemptNumber = 2;
          user.currentSection = 0;
          user.updatedResponses = {};
          user.updatedScores = {};
          user.followUpResponses = {};
          user.followUpScores = {};
          user.openEndedResponses = {};
          user.courses = courses ? courses.split(",") : [];
          user.timeStamps.t2 = new Date(); // Set T2 timestamp
        } else if (attemptType === "T3") {
          user.attemptNumber = 3;
          user.currentSection = 0;
          user.followUpResponses = {};
          user.followUpScores = {};
          user.openEndedResponses = {};
          user.courses = courses ? courses.split(",") : [];
          user.timeStamps.t3 = new Date(); // Set T3 timestamp
        } else {
          // reset T1
          user.attemptNumber = 1;
          user.currentSection = 0;
          // user.data = {}; //REMOVED
          user.initialResponses = {};
          user.updatedResponses = {};
          user.followUpResponses = {};
          user.initialScores = {};
          user.updatedScores = {};
          user.followUpScores = {};
          user.openEndedResponses = {};
          user.courses = courses ? courses.split(",") : [];
          user.timeStamps.t1 = new Date(); // Reset T1 timestamp
        }
        await user.save();
      } else {
        // continuing same attempt
        // Removed:  We'll set timestamps only when saving, not on login
        // user.latestSubmissionTime = new Date();
        await user.save();
      }
    } else {
      // doc does NOT exist => create
      user = new UserData({
        userId: stringUserId,
        // data: {}, //REMOVED
        courses: courses ? [courses] : [],
        isComplete: false,
        timeStamps: { t1: new Date(), t2: null, t3: null }, // Set T1 on creation
        initialScores: {},
        updatedScores: {},
        followUpScores: {},
        initialResponses: {},
        updatedResponses: {},
        followUpResponses: {},
        currentSection: 0,
        datenschutzConsent: false,
        unterschrift: "",
        attemptNumber: 1,
        openEndedResponses: {},
      });
      await user.save();
    }

    return res.status(200).json({
      message: "Login erfolgreich",
      userId: stringUserId,
      isComplete: user.isComplete || false,
      currentSection: user.currentSection || 0,
      startNewAttempt: !!startNewAttempt,
      attemptNumber: user.attemptNumber || 1,
    });
  } catch (err) {
    console.error("Fehler beim Login:", err);
    return res.status(500).json({
      message: "Fehler bei der Verarbeitung der Login-Anfrage",
      error: err.message,
    });
  }
});

// --------------------------------------------------------------------
// 4)  Save user data for T1/T2/T3 (NO doc creation if not found)
app.post("/api/save-user-data", async (req, res) => {
  try {
    const {
      userId,
      data,
      isComplete,
      currentSection,
      datenschutzConsent,
      unterschrift,
      openEndedResponses,
      personalInfo,
      isPersonalInfo,
      attemptNumber,
      preSurveyResponses,
    } = req.body;

    if (!userId) {
      return res.status(400).json({
        message: "Missing userId in request body.",
        success: false,
      });
    }

    let user = await UserData.findOne({ userId });
    if (!user) {
      // do NOT create doc here; user must have logged in
      return res.status(400).json({
        message: "No existing user doc. Please log in or refresh first.",
      });
    }

    // We have user doc, so proceed
    // const now = new Date(); //REMOVED
    // user.latestSubmissionTime = now; //REMOVED
    if (attemptNumber) {
      user.attemptNumber = attemptNumber;
    }

    // Merge personal info
    if (isPersonalInfo && personalInfo) {
      // user.data = { ...user.data, ...personalInfo }; //REMOVED
      //Save personal info in initial, updated and follow up responses
      if (attemptNumber === 1) {
        user.initialResponses = { ...user.initialResponses, ...personalInfo };
      } else if (attemptNumber === 2) {
        user.updatedResponses = { ...user.updatedResponses, ...personalInfo };
      } else if (attemptNumber === 3) {
        user.followUpResponses = { ...user.followUpResponses, ...personalInfo };
      }
    } else if (data) {
      // user.data = { ...user.data, ...data }; //REMOVED
      //Save data in initial, updated and follow up responses
      if (attemptNumber === 1) {
        user.initialResponses = { ...user.initialResponses, ...data };
      } else if (attemptNumber === 2) {
        user.updatedResponses = { ...user.updatedResponses, ...data };
      } else if (attemptNumber === 3) {
        user.followUpResponses = { ...user.followUpResponses, ...data };
      }
    }

    if (currentSection !== undefined) {
      user.currentSection = currentSection;
    }
    if (datenschutzConsent !== undefined) {
      user.datenschutzConsent = datenschutzConsent;
    }
    if (unterschrift) {
      user.unterschrift = unterschrift;
    }
    if (openEndedResponses) {
      user.openEndedResponses = {
        ...user.openEndedResponses,
        ...openEndedResponses,
      };
    }

    // Save pre-survey responses
    if (preSurveyResponses) {
      user.preSurveyResponses = {
        ...user.preSurveyResponses,
        ...preSurveyResponses,
      };
    }

    // If not finished, partial storing (THIS SECTION IS LIKELY REDUNDANT NOW)
    // if (!isComplete) {
    //   if (user.attemptNumber === 1) {
    //     user.initialResponses = {
    //       ...user.initialResponses,
    //       ...data,
    //     };
    //   } else if (user.attemptNumber === 2) {
    //     user.updatedResponses = {
    //       ...user.updatedResponses,
    //       ...data,
    //     };
    //   } else if (user.attemptNumber === 3) {
    //     user.followUpResponses = {
    //       ...user.followUpResponses,
    //       ...data,
    //     };
    //   }
    // }

    // If finishing attempt
    if (isComplete) {
      user.isComplete = true;
      // Removed redundant merging: already done above
      // if (user.attemptNumber === 1) {
      //   user.initialResponses = { ...user.initialResponses, ...data };
      // } else if (user.attemptNumber === 2) {
      //   user.updatedResponses = { ...user.updatedResponses, ...data };
      // } else if (user.attemptNumber === 3) {
      //   user.followUpResponses = { ...user.followUpResponses, ...data };
      // }

      //Correct Calculation
      const calcResult = calculateCategoryScores(
        {
          initialResponses: user.initialResponses,
          updatedResponses: user.updatedResponses,
          followUpResponses: user.followUpResponses,
        },
        surveyData,
        user.attemptNumber // Pass attemptNumber
      );

      if (user.attemptNumber === 1) {
        user.initialScores = calcResult.latest; // Use 'latest' for all
        user.timeStamps.t1 = new Date(); // Set T1 timestamp
      } else if (user.attemptNumber === 2) {
        user.updatedScores = calcResult.latest;
        user.timeStamps.t2 = new Date(); // Set T2 timestamp
      } else if (user.attemptNumber === 3) {
        user.followUpScores = calcResult.latest;
        user.timeStamps.t3 = new Date(); // Set T3 timestamp
      }
    }

    await user.save();
    return res.status(200).json({
      message: "User data saved successfully.",
      success: true,
      attemptNumber: user.attemptNumber,
      isComplete: user.isComplete,
      initialScores: user.initialScores,
      updatedScores: user.updatedScores,
      followUpScores: user.followUpScores,
      openEndedResponses: user.openEndedResponses,
    });
  } catch (err) {
    console.error("Error saving user data:", err);
    return res.status(500).json({
      message: "Error saving user data",
      details: err.message,
      success: false,
    });
  }
});

// --------------------------------------------------------------------
// 5)  Return user data. If doc not found, return an EMPTY doc (not 404)
app.get("/api/user-data/:userId", async (req, res) => {
  const { userId } = req.params;
  try {
    const user = await UserData.findOne({ userId });
    if (!user) {
      // Instead of 404, return a default doc so there's no console error:
      return res.status(200).json({
        courses: [],
        isComplete: false,
        initialScores: {},
        updatedScores: {},
        followUpScores: {},
        initialResponses: {},
        updatedResponses: {},
        followUpResponses: {},
        currentSection: -1,
        datenschutzConsent: false,
        unterschrift: "",
        attemptNumber: 1,
        openEndedResponses: {},
        preSurveyResponses: {},
        userCode: "Unknown",
      });
    }

    // Get the code from Code collection
    const codeDoc = await Code.findOne({ _id: userId });
    const userCode = codeDoc ? codeDoc.code : "Unknown";

    return res.status(200).json({
      courses: user.courses,
      isComplete: user.isComplete,
      initialScores: user.initialScores,
      updatedScores: user.updatedScores,
      followUpScores: user.followUpScores,
      initialResponses: user.initialResponses,
      updatedResponses: user.updatedResponses,
      followUpResponses: user.followUpResponses,
      currentSection: user.currentSection || 0,
      datenschutzConsent: user.datenschutzConsent,
      unterschrift: user.unterschrift || "",
      attemptNumber: user.attemptNumber || 1,
      openEndedResponses: user.openEndedResponses || {},
      preSurveyResponses: user.preSurveyResponses || {},
      userCode: userCode, // Add the user code to the response
    });
  } catch (err) {
    console.error("Error fetching user data:", err);
    return res.status(500).json({ message: "Error fetching user data" });
  }
});

// --------------------------------------------------------------------
// Dashboard login
app.post("/api/dashboard-login", (req, res) => {
  const { userId, password } = req.body;
  if (userId === DASHBOARD_USER_ID && password === DASHBOARD_PASSWORD) {
    const token = jwt.sign({ userId }, JWT_SECRET, { expiresIn: "1h" });
    res.json({ token });
  } else {
    res.status(401).json({ error: "Invalid credentials" });
  }
});

// --------------------------------------------------------------------
// Serve the dashboard
app.get("/dashboard", (req, res) => {
  res.sendFile(path.resolve(__dirname, "docs", "dashboard.html"));
});
app.get("/dashboard-login", (req, res) => {
  res.sendFile(path.resolve(__dirname, "docs", "dashboard-login.html"));
});

// --------------------------------------------------------------------
// 6) Provide dashboard data route
app.get("/api/dashboard-data", authenticate, async (req, res) => {
  try {
    // Example question IDs for scale questions (excluding personal info = index 0):
    // Adjust these as needed if your survey changed
    const questionIds = [];
    surveyData.forEach((section, sIndex) => {
      if (sIndex === 0) return; // skip "Persönliche Angaben"
      section.questions.forEach((q, qIndex) => {
        const key = `q${sIndex}_${qIndex}`;
        questionIds.push(key);
      });
    });

    // Gather all user documents
    const allUsers = await UserData.find().lean();
    const users = [];

    for (const doc of allUsers) {
      // find the code for this doc
      const codeDoc = await Code.findOne({ _id: doc.userId });
      const userCode = codeDoc ? codeDoc.code : "Unknown";

      // Build a minimal data object
      const personalData = {
        // Possibly retrieve "q0_0" (gender?), "q0_1" (year?), etc.
        // q0_0: doc.data?.q0_0 || doc.initialResponses?.q0_0 || "", //REMOVED
        // q0_1: doc.data?.q0_1 || doc.initialResponses?.q0_1 || "", //REMOVED
        // q0_2: doc.data?.q0_2 || doc.initialResponses?.q0_2 || "", //REMOVED
        // q0_3: doc.data?.q0_3 || doc.initialResponses?.q0_3 || "", //REMOVED
        // q0_4: doc.data?.q0_4 || doc.initialResponses?.q0_4 || "", //REMOVED
        // q0_5: doc.data?.q0_5 || doc.initialResponses?.q0_5 || "", //REMOVED
        // q0_6: doc.data?.q0_6 || doc.initialResponses?.q0_6 || "", //REMOVED
        q0_0: doc.initialResponses?.q0_0 || "",
        q0_1: doc.initialResponses?.q0_1 || "",
        q0_2: doc.initialResponses?.q0_2 || "",
        q0_3: doc.initialResponses?.q0_3 || "",
        q0_4: doc.initialResponses?.q0_4 || "",
        q0_5: doc.initialResponses?.q0_5 || "",
        q0_6: doc.initialResponses?.q0_6 || "",
      };

      // Compose result for one user
      users.push({
        userId: doc.userId,
        userCode,
        // data: personalData, //REMOVED
        ...personalData, // Spread personalData directly
        attemptNumber: doc.attemptNumber || 1,
        isComplete: doc.isComplete || false,
        timeStamps: {
          t1: doc.timeStamps?.t1 ? doc.timeStamps.t1.toISOString() : null,
          t2: doc.timeStamps?.t2 ? doc.timeStamps.t2.toISOString() : null,
          t3: doc.timeStamps?.t3 ? doc.timeStamps.t3.toISOString() : null,
        },
        courses: doc.courses || [],
        initialScores: doc.initialScores || {},
        updatedScores: doc.updatedScores || {},
        followUpScores: doc.followUpScores || {},
        initialResponses: doc.initialResponses || {},
        updatedResponses: doc.updatedResponses || {},
        followUpResponses: doc.followUpResponses || {},
        openEndedResponses: doc.openEndedResponses || {},
        datenschutzConsent: doc.datenschutzConsent,
        unterschrift: doc.unterschrift || "",
        currentSection: doc.currentSection || 0,
        preSurveyResponses: doc.preSurveyResponses || {}, // Added for pre-survey questions
      });
    }

    return res.json({ users, questionIds });
  } catch (err) {
    console.error("Error fetching dashboard data:", err);
    return res.status(500).json({
      error: "Error fetching dashboard data",
      details: err.message,
    });
  }
});

// --------------------------------------------------------------------
// Fallback route: serve main index
app.get("*", (req, res) => {
  res.sendFile(path.resolve(__dirname, "docs", "index.html"));
});

// --------------------------------------------------------------------
// Endpoint to save open-ended with userId as string
app.post("/api/save-open-ended-response", async (req, res) => {
  const { userId, key, response } = req.body;
  if (!userId || !response || !key) {
    console.warn(`Invalid open-ended response attempt - Missing data: userId=${userId}, key=${key}`);
    return res
      .status(400)
      .json({ message: "Missing userId, response, or key in request body." });
  }
  try {
    let user = await UserData.findOne({ userId });
    if (!user) {
      console.warn(`Open-ended response failed - User not found: userId=${userId}`);
      return res.status(404).json({ message: "User data not found." });
    }

    // Get group information
    const group = user.preSurveyResponses?.['q-2_1'] || 'Gruppe A';
    const attemptNumber = user.attemptNumber || 1;
    const timestamp = new Date().toISOString();

    // Create log entry
    const logEntry = {
      timestamp,
      userId,
      group,
      attemptNumber: `T${attemptNumber}`,
      questionKey: key,
      responseLength: response.length,
      responseSummary: response.substring(0, 50) + (response.length > 50 ? '...' : '')
    };

    console.log('Open-ended Response Saved:', JSON.stringify(logEntry, null, 2));

    // Corrected expected questions per group and timepoint
    const expectedQuestions = {
      'Gruppe A': {
        1: ['t1_strategy'],
        2: ['t2_reflection', 't2_course_feedback', 't2_course_list'],
        3: ['t3_reflection']
      },
      'Gruppe B': {
        1: ['t1_strategy'],
        2: ['t2_reflection', 't2_course_feedback', 't2_course_list'],
        3: ['t3_reflection']
      },
      'Gruppe C': {
        1: ['t1_strategy'],
        2: ['t2_reflection'],
        3: ['t3_reflection']
      },
      'Gruppe D': {
        1: ['t1_strategy'],
        2: ['t2_reflection'],
        3: ['t3_reflection', 't3_additional_reflection']
      }
    };

    // Check if this question is expected for this group and timepoint
    const isExpectedQuestion = expectedQuestions[group]?.[attemptNumber]?.includes(key);
    if (!isExpectedQuestion) {
      console.warn(`Unexpected question key "${key}" for ${group} at T${attemptNumber}`);
    }

    // Save the response
    user.openEndedResponses = user.openEndedResponses || {};
    user.openEndedResponses[key] = response;
    await user.save();

    // Log completion status for this timepoint
    const timepointQuestions = expectedQuestions[group]?.[attemptNumber] || [];
    const answeredQuestions = Object.keys(user.openEndedResponses);
    const completedQuestions = timepointQuestions.filter(q => answeredQuestions.includes(q));
    
    console.log('Timepoint Completion Status:', {
      userId,
      group,
      timepoint: `T${attemptNumber}`,
      completedQuestions: completedQuestions.length,
      totalQuestions: timepointQuestions.length,
      remainingQuestions: timepointQuestions.filter(q => !answeredQuestions.includes(q))
    });

    return res
      .status(200)
      .json({ 
        message: "Open-ended response saved successfully.",
        completionStatus: {
          completed: completedQuestions.length,
          total: timepointQuestions.length
        }
      });
  } catch (err) {
    console.error("Error saving open-ended response:", {
      error: err.message,
      userId,
      key,
      responseLength: response?.length
    });
    return res.status(500).json({
      message: "Error saving open-ended response",
      details: err.message,
    });
  }
}); // --------------------------------------------------------------------
// Check results endpoint
app.post("/api/check-results", async (req, res) => {
  const { code } = req.body;
  if (!code) {
    return res
      .status(400)
      .json({ success: false, message: "Code is required" });
  }
  try {
    const uppercaseCode = code.toUpperCase();
    const codeDoc = await Code.findOne({ code: uppercaseCode });
    if (!codeDoc) {
      return res
        .status(400)
        .json({ success: false, message: "Ungültiger Code" });
    }
    const stringUserId = codeDoc._id.toString();
    const user = await UserData.findOne({ userId: stringUserId });
    if (!user) {
      return res
        .status(400)
        .json({ success: false, message: "Keine Ergebnisse gefunden" });
    }
    return res.status(200).json({ success: true, userId: stringUserId });
  } catch (err) {
    console.error("Error checking results:", err);
    return res.status(500).json({ success: false, message: "Server error" });
  }
});

// --------------------------------------------------------------------
// Fallback route: serve main index
app.get("*", (req, res) => {
  res.sendFile(path.resolve(__dirname, "docs", "index.html"));
});

// --------------------------------------------------------------------
// Start server
const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
// --------------------------------------------------------------------
