const express = require("express"),
  createCsvWriter = require("csv-writer").createObjectCsvWriter,
  mongoose = require("mongoose"),
  bodyParser = require("body-parser"),
  path = require("path"),
  jwt = require("jsonwebtoken");
require("dotenv").config();
const app = express();
mongoose.set("strictQuery", !1),
  app.use(bodyParser.json()),
  app.use(express.static("docs"));
const mongoURI =
  process.env.MONGODB_URI || "mongodb://localhost:27017/surveyDB";
mongoose
  .connect(mongoURI)
  .then(() => console.log("MongoDB connected"))
  .catch((e) => console.error("MongoDB connection error:", e));
const codeSchema = new mongoose.Schema({ code: String }),
  Code = mongoose.model("Code", codeSchema, "codes"),
  userDataSchema = new mongoose.Schema({
    userId: { type: String, required: !0, unique: !0 },
    data: { type: Object, default: {} },
    courses: { type: [String], default: [] },
    isComplete: { type: Boolean, default: !1 },
    firstSubmissionTime: { type: Date },
    latestSubmissionTime: { type: Date },
    initialScores: { type: Object, default: {} },
    updatedScores: { type: Object, default: {} },
    initialResponses: { type: Object, default: {} },
    updatedResponses: { type: Object, default: {} },
    currentSection: { type: Number, default: 0 },
    datenschutzConsent: { type: Boolean, default: !1 },
    unterschrift: { type: String, default: "" },
    attemptNumber: { type: Number, default: 1 },
    openEndedResponses: { type: Object, default: {} },
  }),
  UserData = mongoose.model("UserData", userDataSchema, "userdatas"),
  JWT_SECRET = process.env.JWT_SECRET || "your-secret-key",
  DASHBOARD_USER_ID = process.env.DASHBOARD_USER_ID || "admin",
  DASHBOARD_PASSWORD = process.env.DASHBOARD_PASSWORD || "password",
  surveyData = require("./docs/js/survey-data.min.js");
function authenticate(e, s, t) {
  const a = e.headers.authorization,
    o = a?.split(" ")[1];
  o
    ? jwt.verify(o, JWT_SECRET, (a, o) => {
        if (a) return s.status(401).json({ error: "Unauthorized" });
        (e.userId = o.userId), t();
      })
    : s.status(401).json({ error: "Unauthorized" });
}
function calculateCategoryScores(e, s) {
  const t = { t1: {}, latest: {} };
  s.forEach((s, a) => {
    if ("Persönliche Angaben" !== s.title && "Abschluss" !== s.title) {
      let o = 0,
        n = 0,
        r = 0;
      if (
        (s.questions.forEach((s, t) => {
          const i = `q${a}_${t}`;
          if ("scale" === s.type) {
            if ((r++, e.initialResponses?.[i])) {
              const s = parseInt(e.initialResponses[i], 10);
              isNaN(s) || (o += s);
            }
            if (e.updatedResponses?.[i]) {
              const s = parseInt(e.updatedResponses[i], 10);
              isNaN(s) || (n += s);
            }
          }
        }),
        r > 0)
      ) {
        const e = 6 * r;
        (t.t1[s.title] = Math.round((o / e) * 100)),
          (t.latest[s.title] = Math.round((n / e) * 100));
      }
    }
  });
  const a = (e) => {
    const s = Object.values(e);
    if (0 === s.length) return 0;
    const t = s.reduce((e, s) => e + s, 0);
    return Math.round(t / s.length);
  };
  return (
    (t.t1.overall = a(t.t1)),
    (t.latest.overall = a(t.latest)),
    (t.metadata = {
      maxScorePerQuestion: 6,
      scoreType: "percentage",
      t1Label: "Initial Assessment",
      latestLabel: `Attempt ${e.attemptNumber || 1}`,
      categories: Object.keys(t.t1).filter((e) => "overall" !== e),
    }),
    t
  );
}
async function updateCSV() {
  const e = await UserData.find().lean(),
    s = createCsvWriter({
      path: "survey_data.csv",
      header: [
        { id: "userId", title: "User ID" },
        { id: "userCode", title: "User Code" },
        { id: "gender", title: "Gender" },
        { id: "birthYear", title: "Birth Year" },
        { id: "firstSubmissionTime", title: "First Submission" },
        { id: "latestSubmissionTime", title: "Latest Submission" },
        { id: "courses", title: "Completed Courses" },
        { id: "courseFeedback", title: "Feedback zu Kursen" },
        { id: "strategy", title: "Strategie bei der Auswahl" },
        { id: "reflection", title: "Veränderung der Kompetenzüberzeugungen" },
        { id: "attemptNumber", title: "Attempt Number" },
        ...surveyData
          .flatMap((s, t) =>
            s.questions.flatMap((s, a) => {
              if (0 === t) return [];
              const o = `q${t}_${a}`;
              return [
                { id: `${o}_t1`, title: `${o} (T1)` },
                { id: `${o}_latest`, title: `${o} (T${e.attemptNumber || 2})` },
              ];
            })
          )
          .filter((e) => e),
      ],
    }),
    t = await Promise.all(
      e.map(async (e) => {
        const s = await Code.findOne({ _id: e.userId }),
          t = {
            userId: e.userId,
            userCode: s ? s.code : "Unknown",
            gender: e.data?.q0_0 || "",
            birthYear: e.data?.q0_1 || "",
            firstSubmissionTime: e.firstSubmissionTime
              ? new Date(e.firstSubmissionTime).toLocaleString()
              : "",
            latestSubmissionTime: e.latestSubmissionTime
              ? new Date(e.latestSubmissionTime).toLocaleString()
              : "",
            courses: e.courses?.join(", ") || "",
            courseFeedback:
              e.openEndedResponses?.attempt2_course_feedback || "",
            strategy: e.openEndedResponses?.t1_strategy || "",
            reflection: e.openEndedResponses?.t2_reflection || "",
            attemptNumber: e.attemptNumber || 1,
          };
        return (
          surveyData.forEach((s, a) => {
            0 !== a &&
              s.questions.forEach((s, o) => {
                const n = `q${a}_${o}`;
                (t[`${n}_t1`] = e.initialResponses?.[n] || ""),
                  (t[`${n}_latest`] = e.updatedResponses?.[n] || "");
              });
          }),
          t
        );
      })
    );
  try {
    await s.writeRecords(t),
      console.log(`CSV file updated successfully with ${t.length} records`);
  } catch (e) {
    throw (
      (console.error("Error updating CSV file:", e),
      new Error(`Failed to write CSV file: ${e.message}`))
    );
  }
}
app.post("/api/reset-user-data", async (e, s) => {
  const { userId: t } = e.body;
  if (!t) return s.status(400).json({ message: "userId is required." });
  try {
    const e = await UserData.findOne({ userId: t });
    if (!e) return s.status(404).json({ message: "User not found." });
    const a = {
      q0_0: e.data.q0_0,
      q0_1: e.data.q0_1,
      q0_2: e.data.q0_2,
      q0_3: e.data.q0_3,
      q0_4: e.data.q0_4,
      q0_5: e.data.q0_5,
      q0_6: e.data.q0_6,
    };
    (e.data = a),
      (e.updatedResponses = {}),
      (e.updatedScores = {}),
      (e.isComplete = !1),
      (e.currentSection = 0),
      await e.save(),
      s.status(200).json({ message: "Survey data reset successfully." });
  } catch (e) {
    console.error("Error resetting user data:", e),
      s.status(500).json({ message: "Error resetting user data." });
  }
}),
  app.post("/register", async (e, s) => {
    const { code: t } = e.body;
    if (!t) return s.status(400).json({ message: "Code is required" });
    try {
      if (await Code.findOne({ code: t }))
        return s
          .status(400)
          .json({
            message:
              "Dieser Code existiert bereits. Bitte verwenden Sie stattdessen die Initialen Ihres Vaters für den zweiten Teil des Codes.",
            isDuplicateCode: !0,
          });
      const e = new Code({ code: t });
      await e.save(),
        s.status(201).json({ message: "Code saved", userId: e._id });
    } catch (e) {
      console.error("Failed to save code:", e),
        s.status(500).json({ message: "Error saving code: " + e.message });
    }
  }),
  app.post("/login", async (e, s) => {
    const { code: t, courses: a, startNewAttempt: o } = e.body;
    try {
      const e = await Code.findOne({ code: t.toUpperCase() });
      if (!e) return s.status(400).json({ message: "Ungültiger Code" });
      let n = await UserData.findOne({ userId: e._id });
      if (n)
        if (o) {
          const e = {
            q0_0: n.data.q0_0,
            q0_1: n.data.q0_1,
            q0_2: n.data.q0_2,
            q0_3: n.data.q0_3,
          };
          (n.data = e),
            (n.updatedResponses = {}),
            (n.updatedScores = {}),
            (n.isComplete = !1),
            (n.currentSection = 0),
            a && !n.courses.includes(a) && n.courses.push(a),
            (n.currentSection = 1),
            (n.attemptNumber = (n.attemptNumber || 1) + 1),
            (n.isComplete = !1),
            await n.save();
        } else (n.latestSubmissionTime = new Date()), await n.save();
      else
        (n = new UserData({
          userId: e._id,
          data: {},
          courses: a ? [a] : [],
          isComplete: !1,
          firstSubmissionTime: new Date(),
          latestSubmissionTime: new Date(),
          initialScores: {},
          updatedScores: {},
          initialResponses: {},
          updatedResponses: {},
          currentSection: 0,
          datenschutzConsent: !1,
          unterschrift: "",
          attemptNumber: 1,
          openEndedResponses: {},
        })),
          await n.save();
      s.status(200).json({
        message: "Login erfolgreich",
        userId: e._id,
        isComplete: n.isComplete || !1,
        currentSection: n.currentSection || 0,
        startNewAttempt: o || !1,
        attemptNumber: n.attemptNumber || 1,
      });
    } catch (e) {
      console.error("Fehler beim Login:", e),
        s
          .status(500)
          .json({
            message: "Fehler bei der Verarbeitung der Login-Anfrage",
            error: e.message,
          });
    }
  }),
  app.post("/api/get-recommendations", async (e, s) => {
    const { userId: t } = e.body;
    try {
      const e = await UserData.findOne({ userId: t });
      if (!e) return s.status(404).json({ error: "User not found" });
      const a = e.attemptNumber > 1 ? e.updatedScores : e.initialScores,
        o = Object.entries(a).map(([e, s]) => ({
          category: e,
          score: s,
          courseLink: `https://ilias.uni-rostock.de/${e}/${Math.floor(s / 25)}`,
        }));
      s.json({ recommendations: o });
    } catch (e) {
      console.error("Recommendation error:", e),
        s.status(500).json({ error: "Failed to generate recommendations" });
    }
  }),
  app.post("/api/save-user-data", async (e, s) => {
    const {
      userId: t,
      data: a,
      isComplete: o,
      categoryScores: n,
      currentSection: r,
      datenschutzConsent: i,
      unterschrift: d,
      openEndedResponses: u,
      personalInfo: c,
      isPersonalInfo: p,
    } = e.body;
    if (!t)
      return s
        .status(400)
        .json({ message: "Missing userId in request body.", success: !1 });
    try {
      let e = await UserData.findOne({ userId: t });
      const n = new Date();
      if (
        (e ||
          (e = new UserData({
            userId: t,
            data: p ? c : {},
            courses: [],
            isComplete: !1,
            firstSubmissionTime: n,
            latestSubmissionTime: n,
            initialScores: {},
            updatedScores: {},
            initialResponses: {},
            updatedResponses: {},
            currentSection: 0,
            datenschutzConsent: !1,
            unterschrift: "",
            attemptNumber: 1,
            openEndedResponses: {},
          })),
        p && c
          ? (e.data = { ...e.data, ...c })
          : a && (e.data = { ...e.data, ...a }),
        (e.currentSection = void 0 !== r ? r : e.currentSection),
        (e.latestSubmissionTime = n),
        (e.isComplete = o),
        o)
      ) {
        if (e.initialScores && 0 !== Object.keys(e.initialScores).length) {
          console.log("Setting updated scores and responses", e.attemptNumber);
          const s = calculateCategoryScores(
            {
              initialResponses: e.initialResponses,
              updatedResponses: a,
              attemptNumber: e.attemptNumber,
            },
            surveyData
          );
          (e.updatedScores = s.latest), (e.updatedResponses = { ...a });
        } else {
          console.log("Setting initial scores and responses");
          const s = calculateCategoryScores(
            { initialResponses: a, attemptNumber: 1 },
            surveyData
          );
          (e.initialScores = s.t1),
            (e.initialResponses = { ...a }),
            (e.updatedScores = {}),
            (e.updatedResponses = {});
        }
        console.log("Initial Scores:", e.initialScores),
          console.log("Updated Scores:", e.updatedScores),
          console.log("Attempt Number:", e.attemptNumber);
      }
      void 0 !== i && (e.datenschutzConsent = i),
        d && (e.unterschrift = d),
        u && (e.openEndedResponses = { ...e.openEndedResponses, ...u }),
        await e.save(),
        s
          .status(200)
          .json({
            message: "User data saved successfully.",
            success: !0,
            initialScores: e.initialScores,
            updatedScores: e.updatedScores,
            isComplete: e.isComplete,
            openEndedResponses: e.openEndedResponses,
            attemptNumber: e.attemptNumber,
          });
    } catch (e) {
      console.error("Error saving user data:", e),
        s
          .status(500)
          .json({
            message: "Error saving user data",
            details: e.message,
            success: !1,
          });
    }
  }),
  app.get("/api/user-data/:userId", async (e, s) => {
    const { userId: t } = e.params;
    try {
      const e = await UserData.findOne({ userId: t });
      e
        ? s
            .status(200)
            .json({
              data: e.data,
              courses: e.courses,
              isComplete: e.isComplete,
              initialScores: e.initialScores,
              updatedScores: e.updatedScores,
              initialResponses: e.initialResponses,
              updatedResponses: e.updatedResponses,
              currentSection: e.currentSection || 0,
              datenschutzConsent: e.datenschutzConsent,
              unterschrift: e.unterschrift || "",
              attemptNumber: e.attemptNumber || 1,
            })
        : s.status(404).json({ message: "User data not found" });
    } catch (e) {
      console.error("Error fetching user data:", e),
        s.status(500).json({ message: "Error fetching user data" });
    }
  }),
  app.post("/api/dashboard-login", (e, s) => {
    const { userId: t, password: a } = e.body;
    if (t === DASHBOARD_USER_ID && a === DASHBOARD_PASSWORD) {
      const e = jwt.sign({ userId: t }, JWT_SECRET, { expiresIn: "1h" });
      s.json({ token: e });
    } else s.status(401).json({ error: "Invalid credentials" });
  }),
  app.get("/dashboard", (e, s) => {
    s.sendFile(path.resolve(__dirname, "docs", "dashboard.html"));
  }),
  app.get("/dashboard-login", (e, s) => {
    s.sendFile(path.resolve(__dirname, "docs", "dashboard-login.html"));
  }),
  app.get("/api/dashboard-data", authenticate, async (e, s) => {
    try {
      const e = await UserData.find().lean(),
        t = [
          "q0_0",
          "q0_1",
          "q1_0",
          "q1_1",
          "q1_2",
          "q1_3",
          "q1_4",
          "q1_5",
          "q2_0",
          "q2_1",
          "q2_2",
          "q2_3",
          "q2_4",
          "q2_5",
          "q2_6",
          "q3_0",
          "q3_1",
          "q3_2",
          "q3_3",
          "q3_4",
          "q3_5",
          "q3_6",
          "q4_0",
          "q4_1",
          "q4_2",
          "q4_3",
          "q4_4",
          "q4_5",
          "q5_0",
          "q5_1",
          "q5_2",
          "q5_3",
          "q5_4",
          "q5_5",
          "q5_6",
          "q6_0",
          "q6_1",
          "q6_2",
          "q6_3",
          "q6_4",
          "q6_5",
        ],
        a = surveyData
          .map((e) => e.title)
          .filter((e) => "Persönliche Angaben" !== e && "Abschluss" !== e),
        o = await Promise.all(
          e.map(async (e) => {
            const s = await Code.findOne({ _id: e.userId }),
              a = e.data || {},
              o = {};
            return (
              t
                .filter(
                  (e) =>
                    e.startsWith("q") &&
                    "q0_0" !== e &&
                    "q0_1" !== e &&
                    "q0_2" !== e &&
                    "q0_3" !== e
                )
                .forEach((s) => {
                  (o[`${s}_t1`] = e.initialResponses?.[s] || ""),
                    (o[`${s}_t${e.attemptNumber || 1}`] =
                      e.updatedResponses?.[s] || "");
                }),
              {
                userId: e.userId,
                userCode: s ? s.code : "Unknown",
                gender: a.q0_0 || "",
                birthYear: a.q0_1 || "",
                firstSubmissionTime: e.firstSubmissionTime
                  ? e.firstSubmissionTime.toISOString()
                  : "",
                latestSubmissionTime: e.latestSubmissionTime
                  ? e.latestSubmissionTime.toISOString()
                  : "",
                data: {
                  responses: a,
                  formattedResponses: o,
                  openEndedResponses: e.openEndedResponses || {},
                  strategy: e.openEndedResponses?.t1_strategy || "",
                },
                isComplete: e.isComplete || !1,
                courses: e.courses || [],
                initialScores: e.initialScores || {},
                updatedScores: e.updatedScores || {},
                initialResponses: e.initialResponses || {},
                updatedResponses: e.updatedResponses || {},
                datenschutzConsent: e.datenschutzConsent,
                unterschrift: e.unterschrift || "",
                openEndedResponses: e.openEndedResponses || {},
                strategieAuswahl: e.openEndedResponses?.t1_strategy || "",
                veraenderungKompetenz:
                  e.openEndedResponses?.t2_reflection || "",
                attemptNumber: e.attemptNumber || 1,
                questionResponses: {
                  t1: e.initialResponses || {},
                  [`t${e.attemptNumber || 1}`]: e.updatedResponses || {},
                },
              }
            );
          })
        ),
        n = {
          format: {
            t1: "Initial responses from first attempt",
            latest: "Responses from latest attempt (T2, T3, etc.)",
          },
          questionCount: t.filter(
            (e) =>
              e.startsWith("q") &&
              "q0_0" !== e &&
              "q0_1" !== e &&
              "q0_2" !== e &&
              "q0_3" !== e
          ).length,
        };
      s.json({ users: o, sections: a, metadata: n, questionIds: t });
    } catch (e) {
      console.error("Error fetching dashboard data:", e),
        s
          .status(500)
          .json({ error: "Error fetching dashboard data", details: e.message });
    }
  }),
  app.get("*", (e, s) => {
    s.sendFile(path.resolve(__dirname, "docs", "index.html"));
  });
const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
}),
  app.post("/api/save-open-ended-response", async (e, s) => {
    const { userId: t, key: a, response: o } = e.body;
    if (!t || !o || !a)
      return s
        .status(400)
        .json({ message: "Missing userId, response, or key in request body." });
    try {
      const e = new mongoose.Types.ObjectId(t);
      let n = await UserData.findOne({ userId: e });
      if (!n) return s.status(404).json({ message: "User data not found." });
      n.openEndedResponses || (n.openEndedResponses = {}),
        (n.openEndedResponses[a] = o),
        await n.save(),
        s
          .status(200)
          .json({ message: "Open-ended response saved successfully." });
    } catch (e) {
      console.error("Error saving open-ended response:", e),
        s
          .status(500)
          .json({
            message: "Error saving open-ended response",
            details: e.message,
          });
    }
  });
