require("dotenv").config();
const express = require("express");
const createCsvWriter = require("csv-writer").createObjectCsvWriter;
const mongoose = require("mongoose");
const bodyParser = require("body-parser");
const path = require("path");
const jwt = require("jsonwebtoken");
const app = express();

mongoose.set("strictQuery", false);
app.use(bodyParser.json());
app.use(express.static("docs"));

// --------------------------------------------------------------------
// Connect to MongoDB
const mongoURI =
  process.env.MONGODB_URI || "mongodb://localhost:27017/surveyDB";
mongoose
  .connect(mongoURI)
  .then(() => console.log("MongoDB connected"))
  .catch((err) => console.error("MongoDB connection error:", err));

// --------------------------------------------------------------------
// CODE SCHEMA
const codeSchema = new mongoose.Schema({ code: String });
const Code = mongoose.model("Code", codeSchema, "codes");

// --------------------------------------------------------------------
// USERDATA SCHEMA  (userId is a STRING, unique)
const userDataSchema = new mongoose.Schema({
  userId: { type: String, required: true, unique: true },
  courses: { type: [String], default: [] },
  isComplete: { type: Boolean, default: false },
  timeStamps: {
    t1: { type: Date, default: null },
    t2: { type: Date, default: null },
    t3: { type: Date, default: null },
  },
  initialScores: { type: Object, default: {} },
  updatedScores: { type: Object, default: {} },
  followUpScores: { type: Object, default: {} },
  initialResponses: { type: Object, default: {} },
  updatedResponses: { type: Object, default: {} },
  followUpResponses: { type: Object, default: {} },
  currentSection: { type: Number, default: 0 },
  datenschutzConsent: { type: Boolean, default: false },
  unterschrift: { type: String, default: "" },
  attemptNumber: { type: Number, default: 1 },
  openEndedResponses: { type: Object, default: {} },
  // New internal flags for survey completion per attempt:
  t1Complete: { type: Boolean, default: false },
  t2Complete: { type: Boolean, default: false },
  t3Complete: { type: Boolean, default: false },
});

const UserData = mongoose.model("UserData", userDataSchema, "userdatas");

// --------------------------------------------------------------------
// Admin login constants
const JWT_SECRET = process.env.JWT_SECRET || "your-secret-key";
const DASHBOARD_USER_ID = process.env.DASHBOARD_USER_ID || "admin";
const DASHBOARD_PASSWORD = process.env.DASHBOARD_PASSWORD || "password";

// --------------------------------------------------------------------
// Load the surveyData
const surveyData = require("./docs/js/survey-data.min.js");

// Add a new API endpoint to serve the survey data
app.get("/api/survey-data", (req, res) => {
  res.json(surveyData);
});

// --------------------------------------------------------------------
// A simple helper for protecting dashboard routes
function authenticate(req, res, next) {
  const authHeader = req.headers.authorization;
  const token = authHeader?.split(" ")[1];
  if (!token) {
    return res.status(401).json({ error: "Unauthorized" });
  }
  jwt.verify(token, JWT_SECRET, (err, decoded) => {
    if (err) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    req.userId = decoded.userId;
    next();
  });
}

async function calculateCategoryScores(user, survey, attemptNumber) {
  const result = {};
  const responses =
    attemptNumber === 1
      ? user.initialResponses
      : attemptNumber === 2
      ? user.updatedResponses
      : user.followUpResponses;

  if (!responses) {
    // If no responses are found for the given attempt, return an empty object
    return {};
  }

  survey.forEach((section, sIndex) => {
    if (
      section.title !== "Persönliche Angaben" &&
      section.title !== "Abschluss"
    ) {
      let sum = 0;
      let questionCount = 0;
      section.questions.forEach((question, qIndex) => {
        if (question.type === "scale") {
          const key = `q${sIndex}_${qIndex}`;
          const value = parseInt(responses[key], 10);
          if (!isNaN(value)) {
            sum += value;
            questionCount++;
          }
        }
      });

      if (questionCount > 0) {
        const max = 6 * questionCount;
        result[section.title] = Math.round((sum / max) * 100);
      }
    }
  });

  const values = Object.values(result);
  const overall =
    values.length > 0
      ? Math.round(values.reduce((a, b) => a + b, 0) / values.length)
      : 0;
  result.overall = overall;

  return result;
}

// --------------------------------------------------------------------
// 1)  Reset user data except T1
app.post("/api/reset-user-data", async (req, res) => {
  const { userId } = req.body;
  if (!userId) {
    return res.status(400).json({ message: "userId is required." });
  }
  try {
    const user = await UserData.findOne({ userId });
    if (!user) {
      return res.status(404).json({ message: "User not found." });
    }
    // Keep only T1 subset
    const t1Subset = {
      q0_0: user.data.q0_0,
      q0_1: user.data.q0_1,
      q0_2: user.data.q0_2,
      q0_3: user.data.q0_3,
      q0_4: user.data.q0_4,
      q0_5: user.data.q0_5,
      q0_6: user.data.q0_6,
    };
    user.data = t1Subset;
    user.updatedResponses = {};
    user.updatedScores = {};
    user.followUpResponses = {};
    user.followUpScores = {};
    user.isComplete = false;
    user.currentSection = 0;
    await user.save();
    return res.status(200).json({ message: "Survey data reset successfully." });
  } catch (err) {
    console.error("Error resetting user data:", err);
    return res.status(500).json({ message: "Error resetting user data." });
  }
});

// --------------------------------------------------------------------
// 2)  Register a new code
app.post("/register", async (req, res) => {
  const { code } = req.body;
  if (!code) {
    return res.status(400).json({ message: "Code is required" });
  }
  try {
    const uppercaseCode = code.toUpperCase();
    const existingCode = await Code.findOne({ code: uppercaseCode });
    if (existingCode) {
      return res.status(400).json({
        message:
          "Dieser Code existiert bereits. Bitte verwenden Sie einen anderen Code.",
        isDuplicateCode: true,
      });
    }
    const newCode = new Code({ code: uppercaseCode });
    await newCode.save();

    return res.status(201).json({ message: "Code saved", userId: newCode._id });
  } catch (err) {
    console.error("Failed to save code:", err);
    return res
      .status(500)
      .json({ message: "Error saving code: " + err.message });
  }
});

app.post("/login", async (req, res) => {
  try {
    const { code, surveyOption, t2CourseList } = req.body;

    if (!code) {
      return res
        .status(400)
        .json({ message: "Bitte geben Sie einen Code ein." });
    }

    const uppercaseCode = code.toUpperCase();

    // 1. Validate the code *first*
    const codeDoc = await Code.findOne({ code: uppercaseCode });
    if (!codeDoc) {
      return res.status(400).json({ message: "Ungültiger Code" }); // Corrected error message
    }

    const stringUserId = codeDoc._id.toString();

    let user = await UserData.findOne({ userId: stringUserId });

    if (!user) {
      // New user: create a new document
      user = new UserData({
        userId: stringUserId,
        attemptNumber: 1, // Start at attempt 1
        currentSection: -1, // Start at Datenschutz
        isComplete: false,
        t1Complete: false,
        t2Complete: false,
        t3Complete: false,
        initialResponses: {},
        updatedResponses: {},
        followUpResponses: {},
        openEndedResponses: {},
        timeStamps: { t1: null, t2: null, t3: null },
        courses: [],
      });
    } else {
      // Existing user: validate surveyOption and update attemptNumber
      if (surveyOption === "redo") {
        if (!user.t1Complete) {
          return res
            .status(400)
            .json({ message: "Sie müssen zuerst T1 abschließen." });
        }
        user.attemptNumber = 2;
        user.t2Complete = false; // Reset T2 completion
        user.currentSection = 0;
      } else if (surveyOption === "followup") {
        if (!user.t2Complete) {
          return res
            .status(400)
            .json({ message: "Sie müssen zuerst T2 abschließen." });
        }
        user.attemptNumber = 3;
        user.t3Complete = false; // Reset T3 completion.
        user.currentSection = 0;
      }
      // "continue" case:  attemptNumber and completion flags remain as they are.
    }

    // Store the free-text “Welche Kurse…” in openEndedResponses, if provided:
    if (t2CourseList && t2CourseList.trim() !== "") {
      user.openEndedResponses = {
        ...user.openEndedResponses,
        t2_course_list: t2CourseList.trim(),
      };
    }

    await user.save();

    return res.status(200).json({
      message: "Login erfolgreich",
      userId: user.userId,
      attemptNumber: user.attemptNumber,
      t1Complete: user.t1Complete,
      t2Complete: user.t2Complete,
      t3Complete: user.t3Complete,
    });
  } catch (err) {
    console.error("Fehler beim Login:", err);
    return res.status(500).json({
      message: "Fehler bei der Verarbeitung der Login-Anfrage",
      error: err.message,
    });
  }
});

app.post("/api/save-user-data", async (req, res) => {
  try {
    const {
      userId,
      data,
      isComplete,
      currentSection,
      datenschutzConsent,
      unterschrift,
      openEndedResponses,
      attemptNumber,
      courses,
    } = req.body;

    if (!userId) {
      return res.status(400).json({ message: "Missing userId." });
    }

    let user = await UserData.findOne({ userId });
    if (!user) {
      user = new UserData({
        userId,
        currentSection: currentSection !== undefined ? currentSection : -1,
        datenschutzConsent: datenschutzConsent || false,
        unterschrift: unterschrift || "",
        attemptNumber: attemptNumber || 1,
      });
    }

    // Update common fields
    user.latestSubmissionTime = new Date();
    if (attemptNumber) user.attemptNumber = attemptNumber;
    if (currentSection !== undefined) user.currentSection = currentSection;
    if (datenschutzConsent !== undefined)
      user.datenschutzConsent = datenschutzConsent;
    if (unterschrift) user.unterschrift = unterschrift;

    // *** MODIFIED COURSES HANDLING ***
    if (Array.isArray(courses)) {
      user.courses = courses; // Use directly if it's already an array
    } else if (typeof courses === "string" && courses.trim() !== "") {
      user.courses = courses.split(",").map((c) => c.trim()); // Split if it's a non-empty string
    } else {
      user.courses = []; // Default to an empty array if it's undefined, null, or an empty string
    }

    // Update timestamps for T1, T2, or T3
    if (user.attemptNumber === 1) {
      user.timeStamps.t1 = new Date();
    } else if (user.attemptNumber === 2) {
      user.timeStamps.t2 = new Date();
    } else if (user.attemptNumber === 3) {
      user.timeStamps.t3 = new Date();
    }

    // Merge open-ended responses
    if (openEndedResponses) {
      user.openEndedResponses = {
        ...user.openEndedResponses,
        ...openEndedResponses,
      };
    }

    // Extract courses from openEndedResponses (T2 only)
    if (attemptNumber === 2) {
      if (user.openEndedResponses && user.openEndedResponses.t2_course_list) {
        const courseString = user.openEndedResponses.t2_course_list;
        if (typeof courseString === "string" && courseString.trim() !== "") {
          user.courses = courseString.split(",").map((c) => c.trim());
        } else {
          user.courses = []; // Default to empty if not a valid string
        }
      } else {
        user.courses = []; // Default to empty if t2_course_list is missing
      }
    } else {
      // Ensure courses is an array even if not T2
      user.courses = Array.isArray(courses) ? courses : [];
    }

    // Handle data saving and score calculation.
    // Also set the completion flag when the survey is finished.
    if (isComplete) {
      user.isComplete = true;
      if (attemptNumber === 1) {
        user.initialResponses = { ...user.initialResponses, ...data };
        user.initialScores = await calculateCategoryScores(user, surveyData, 1);
        user.t1Complete = true;
      } else if (attemptNumber === 2) {
        user.updatedResponses = { ...user.updatedResponses, ...data };
        user.updatedScores = await calculateCategoryScores(user, surveyData, 2);
        user.t2Complete = true;
      } else if (attemptNumber === 3) {
        user.followUpResponses = { ...user.followUpResponses, ...data };
        user.followUpScores = await calculateCategoryScores(
          user,
          surveyData,
          3
        );
        user.t3Complete = true;
      }
    } else {
      // Partial save logic – do not update the complete flag.
      if (attemptNumber === 1) {
        user.initialResponses = { ...user.initialResponses, ...data };
      } else if (attemptNumber === 2) {
        user.updatedResponses = { ...user.updatedResponses, ...data };
      } else if (attemptNumber === 3) {
        user.followUpResponses = { ...user.followUpResponses, ...data };
      }
    }

    await user.save();

    const responseData = {
      message: "User data saved successfully.",
      success: true,
      attemptNumber: user.attemptNumber,
      isComplete: user.isComplete,
      initialScores: user.initialScores,
      updatedScores: user.updatedScores,
      followUpScores: user.followUpScores,
      openEndedResponses: user.openEndedResponses,
    };
    return res.status(200).json(responseData);
  } catch (err) {
    console.error("Error saving user data:", err);
    return res.status(500).json({
      message: "Error saving user data",
      details: err.message,
      success: false,
    });
  }
});

// --------------------------------------------------------------------
// 5)  Return user data. If doc not found, return an EMPTY doc (not 404)
app.get("/api/user-data/:userId", async (req, res) => {
  const { userId } = req.params;
  try {
    const user = await UserData.findOne({ userId });
    if (!user) {
      // Instead of 404, return a default doc so there's no console error:
      return res.status(200).json({
        data: {},
        courses: [],
        isComplete: false,
        initialScores: {},
        updatedScores: {},
        followUpScores: {},
        initialResponses: {},
        updatedResponses: {},
        followUpResponses: {},
        currentSection: -1,
        datenschutzConsent: false,
        unterschrift: "",
        attemptNumber: 1,
        openEndedResponses: {},
        t1Complete: false,
        t2Complete: false,
        t3Complete: false,
      });
    }
    return res.status(200).json({
      data: user.data, //This line seems unnecessary
      courses: user.courses,
      isComplete: user.isComplete,
      initialScores: user.initialScores,
      updatedScores: user.updatedScores,
      followUpScores: user.followUpScores,
      initialResponses: user.initialResponses,
      updatedResponses: user.updatedResponses,
      followUpResponses: user.followUpResponses,
      currentSection: user.currentSection || 0,
      datenschutzConsent: user.datenschutzConsent,
      unterschrift: user.unterschrift || "",
      attemptNumber: user.attemptNumber || 1,
      openEndedResponses: user.openEndedResponses || {},
      t1Complete: user.t1Complete, // Return completion flags
      t2Complete: user.t2Complete,
      t3Complete: user.t3Complete,
    });
  } catch (err) {
    console.error("Error fetching user data:", err);
    return res.status(500).json({ message: "Error fetching user data" });
  }
});

// --------------------------------------------------------------------
// Dashboard login
app.post("/api/dashboard-login", async (req, res) => {
  // Made async
  const { userId, password } = req.body;
  if (userId === DASHBOARD_USER_ID && password === DASHBOARD_PASSWORD) {
    const token = jwt.sign({ userId }, JWT_SECRET, { expiresIn: "1h" });
    res.json({ token });
  } else {
    res.status(401).json({ error: "Invalid credentials" });
  }
});

// --------------------------------------------------------------------
// 7) Check results endpoint
app.post("/api/check-results", async (req, res) => {
  const { code } = req.body;
  if (!code) {
    return res.status(400).json({ success: false, message: "Code required." });
  }

  try {
    const uppercaseCode = code.toUpperCase();
    const codeDoc = await Code.findOne({ code: uppercaseCode });
    if (!codeDoc) {
      return res.status(404).json({ success: false, message: "Invalid code." });
    }

    const userData = await UserData.findOne({ userId: codeDoc._id.toString() });
    if (!userData || !userData.isComplete) {
      return res.status(404).json({
        success: false,
        message: "Results not available for this code.",
      });
    }

    return res.json({
      success: true,
      userId: userData.userId,
    });
  } catch (error) {
    console.error("Error checking results:", error);
    return res
      .status(500)
      .json({ success: false, message: "Internal server error." });
  }
});

// --------------------------------------------------------------------
// Serve the dashboard
app.get("/dashboard", (req, res) => {
  res.sendFile(path.resolve(__dirname, "docs", "dashboard.html"));
});
app.get("/dashboard-login", (req, res) => {
  res.sendFile(path.resolve(__dirname, "docs", "dashboard-login.html"));
});

// --------------------------------------------------------------------
// 6) Provide dashboard data route
app.get("/api/dashboard-data", authenticate, async (req, res) => {
  try {
    // Example question IDs for scale questions (excluding personal info = index 0):
    // Adjust these as needed if your survey changed
    const questionIds = [];
    surveyData.forEach((section, sIndex) => {
      if (sIndex === 0) return; // skip "Persönliche Angaben"
      section.questions.forEach((q, qIndex) => {
        const key = `q${sIndex}_${qIndex}`;
        questionIds.push(key);
      });
    });

    // Gather all user documents
    const allUsers = await UserData.find().lean();
    const users = [];

    for (const doc of allUsers) {
      // find the code for this doc
      const codeDoc = await Code.findOne({ _id: doc.userId });
      const userCode = codeDoc ? codeDoc.code : "Unknown";

      // Determine the correct response object based on attemptNumber
      const attemptNumber = doc.attemptNumber || 1;
      let personalData = {};

      if (attemptNumber === 1) {
        personalData = doc.initialResponses || {};
      } else if (attemptNumber === 2) {
        personalData = doc.updatedResponses || {};
        // Fallback to initialResponses
        for (const key in doc.initialResponses) {
          if (!(key in personalData)) {
            personalData[key] = doc.initialResponses[key];
          }
        }
      } else {
        // attemptNumber === 3
        personalData = doc.followUpResponses || {};
        // Fallback to updatedResponses, then initialResponses
        for (const key in doc.updatedResponses) {
          if (!(key in personalData)) {
            personalData[key] = doc.updatedResponses[key];
          }
        }
        for (const key in doc.initialResponses) {
          if (!(key in personalData)) {
            personalData[key] = doc.initialResponses[key];
          }
        }
      }

      // Extract personal data fields with correct names
      const gender = personalData.q0_0 || "";
      const birthYear = personalData.q0_1 || "";
      const studiesTeaching = personalData.q0_2 || "";
      const teachingType = personalData.q0_6 || ""; // Corrected
      const subjects = personalData.q0_7 || ""; // Corrected
      const otherStudies = personalData.q0_8 || ""; // Corrected
      const semester = personalData.q0_3 || ""; // Corrected

      // Compose result for one user
      users.push({
        userId: doc.userId,
        userCode,
        personalData, // Use the extracted personalData object
        attemptNumber: doc.attemptNumber || 1,
        isComplete: doc.isComplete || false,
        timeStamps: {
          t1: doc.timeStamps?.t1 ? doc.timeStamps.t1.toISOString() : null,
          t2: doc.timeStamps?.t2 ? doc.timeStamps.t2.toISOString() : null,
          t3: doc.timeStamps?.t3 ? doc.timeStamps.t3.toISOString() : null,
        },
        courses: doc.courses || [],
        initialScores: doc.initialScores || {},
        updatedScores: doc.updatedScores || {},
        followUpScores: doc.followUpScores || {},
        initialResponses: doc.initialResponses || {},
        updatedResponses: doc.updatedResponses || {},
        followUpResponses: doc.followUpResponses || {},
        openEndedResponses: doc.openEndedResponses || {},
        datenschutzConsent: doc.datenschutzConsent,
        unterschrift: doc.unterschrift || "",
        currentSection: doc.currentSection || 0,
        // Add the completion flags here:
        t1Complete: doc.t1Complete,
        t2Complete: doc.t2Complete,
        t3Complete: doc.t3Complete,
      });
    }

    return res.json({ users, questionIds });
  } catch (err) {
    console.error("Error fetching dashboard data:", err);
    return res.status(500).json({
      error: "Error fetching dashboard data",
      details: err.message,
    });
  }
});

// --------------------------------------------------------------------
// Fallback route: serve main index
app.get("*", (req, res) => {
  res.sendFile(path.resolve(__dirname, "docs", "index.html"));
});

// --------------------------------------------------------------------
// Endpoint to save open-ended with userId as string
app.post("/api/save-open-ended-response", async (req, res) => {
  const { userId, key, response } = req.body;
  if (!userId || !response || !key) {
    return res
      .status(400)
      .json({ message: "Missing userId, response, or key in request body." });
  }
  try {
    // Use findOneAndUpdate with $set
    const updatedUser = await UserData.findOneAndUpdate(
      { userId: userId }, // Find the user by userId
      { $set: { [`openEndedResponses.${key}`]: response } }, // Update the specific key within openEndedResponses
      { new: true, upsert: false } // Return the updated document.  Do NOT create if it doesn't exist.
    );

    if (!updatedUser) {
      return res.status(404).json({ message: "User data not found." });
    }

    return res
      .status(200)
      .json({ message: "Open-ended response saved successfully." });
  } catch (err) {
    console.error("Error saving open-ended response:", err);
    return res.status(500).json({
      message: "Error saving open-ended response",
      details: err.message,
    });
  }
});

// --------------------------------------------------------------------
// Start server
const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
