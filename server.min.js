require("dotenv").config();
const express = require("express");
const createCsvWriter = require("csv-writer").createObjectCsvWriter;
const mongoose = require("mongoose");
const bodyParser = require("body-parser");
const path = require("path");
const jwt = require("jsonwebtoken");
const app = express();

mongoose.set("strictQuery", false);
app.use(bodyParser.json());
app.use(express.static("docs"));

const mongoURI =
  process.env.MONGODB_URI || "mongodb://localhost:27017/surveyDB";

mongoose
  .connect(mongoURI)
  .then(() => console.log("MongoDB connected"))
  .catch((err) => console.error("MongoDB connection error:", err));

const codeSchema = new mongoose.Schema({
  code: String,
});
const Code = mongoose.model("Code", codeSchema, "codes");

/* Extended schema to include T3 fields (followUpScores, followUpResponses). */
const userDataSchema = new mongoose.Schema({
  userId: { type: String, required: true, unique: true },
  data: { type: Object, default: {} },
  courses: { type: [String], default: [] },
  isComplete: { type: Boolean, default: false },
  timeStamps: {
    t1: {
      type: Date, // Using Date type to store both date and time
      default: null,
    },
    t2: {
      type: Date,
      default: null,
    },
    t3: {
      type: Date,
      default: null,
    },
  },
  initialScores: { type: Object, default: {} },
  updatedScores: { type: Object, default: {} },
  followUpScores: { type: Object, default: {} },
  initialResponses: { type: Object, default: {} },
  updatedResponses: { type: Object, default: {} },
  followUpResponses: { type: Object, default: {} },
  currentSection: { type: Number, default: 0 },
  datenschutzConsent: { type: Boolean, default: false },
  unterschrift: { type: String, default: "" },
  attemptNumber: { type: Number, default: 1 },
  openEndedResponses: { type: Object, default: {} },
});
const UserData = mongoose.model("UserData", userDataSchema, "userdatas");

const JWT_SECRET = process.env.JWT_SECRET || "your-secret-key";
const DASHBOARD_USER_ID = process.env.DASHBOARD_USER_ID || "admin";
const DASHBOARD_PASSWORD = process.env.DASHBOARD_PASSWORD || "password";

const surveyData = require("./docs/js/survey-data.min.js");

/* Simple authentication for dashboard routes */
function authenticate(req, res, next) {
  const authHeader = req.headers.authorization;
  const token = authHeader?.split(" ")[1];
  if (!token) {
    return res.status(401).json({ error: "Unauthorized" });
  }
  jwt.verify(token, JWT_SECRET, (err, decoded) => {
    if (err) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    req.userId = decoded.userId;
    next();
  });
}

/* Calculate T1 vs "latest" attempt. This function focuses on T1 and T2 data in updatedResponses,
   but if T3 is being set, we rely on how the code invests the data. The function checks
   user.initialResponses & user.updatedResponses for "latest" but does not directly handle T3. */
function calculateCategoryScores(user, survey) {
  const result = { t1: {}, latest: {} };

  survey.forEach((section, sectionIndex) => {
    if (
      section.title !== "Persönliche Angaben" &&
      section.title !== "Abschluss"
    ) {
      let sumT1 = 0;
      let sumLatest = 0;
      let questionCount = 0;

      section.questions.forEach((question, questionIdx) => {
        const key = `q${sectionIndex}_${questionIdx}`;
        if (question.type === "scale") {
          questionCount++;
          // T1
          if (user.initialResponses?.[key]) {
            const valT1 = parseInt(user.initialResponses[key], 10);
            if (!isNaN(valT1)) sumT1 += valT1;
          }
          // "latest" (T2 or T3 usage in code below depends on whether we store T3 data
          // into updatedResponses or followUpResponses).
          if (user.updatedResponses?.[key]) {
            const valLatest = parseInt(user.updatedResponses[key], 10);
            if (!isNaN(valLatest)) sumLatest += valLatest;
          }
        }
      });

      if (questionCount > 0) {
        const maxPerSection = 6 * questionCount;
        result.t1[section.title] = Math.round((sumT1 / maxPerSection) * 100);
        result.latest[section.title] = Math.round(
          (sumLatest / maxPerSection) * 100
        );
      }
    }
  });

  function averageScore(scoresObj) {
    const vals = Object.values(scoresObj);
    if (vals.length === 0) return 0;
    const sum = vals.reduce((acc, val) => acc + val, 0);
    return Math.round(sum / vals.length);
  }

  result.t1.overall = averageScore(result.t1);
  result.latest.overall = averageScore(result.latest);

  result.metadata = {
    maxScorePerQuestion: 6,
    scoreType: "percentage",
    t1Label: "Initial Assessment",
    latestLabel: `Attempt ${user.attemptNumber || 1}`,
    categories: Object.keys(result.t1).filter((k) => k !== "overall"),
  };
  return result;
}

/* CSV Export function updated to handle T1, T2, and T3 columns explicitly. */
async function updateCSV() {
  const users = await UserData.find().lean();
  const csvWriter = createCsvWriter({
    path: "survey_data.csv",
    header: [
      { id: "userId", title: "User ID" },
      { id: "userCode", title: "User Code" },
      { id: "gender", title: "Gender" },
      { id: "birthYear", title: "Birth Year" },
      { id: "timeStamps.t1", title: "First Submission" },
      { id: "timeStamps.t2", title: "Second Submission" },
      { id: "timeStamps.t3", title: "Latest Submission" },
      { id: "courses", title: "Completed Courses" },
      { id: "courseFeedback", title: "Feedback zu Kursen" },
      { id: "strategy", title: "Strategie bei der Auswahl" },
      { id: "reflection", title: "Veränderung der Kompetenzüberzeugungen" },
      { id: "attemptNumber", title: "Attempt Number" },
      // For each question, we now generate columns for T1, T2, T3 explicitly
      ...surveyData
        .flatMap((section, sectionIndex) =>
          section.questions.flatMap((question, questionIndex) => {
            // skip the personal info block if needed, or keep them
            // if we do skip them, do something like:
            if (sectionIndex === 0) return []; // ignoring "Persönliche Angaben"
            const key = `q${sectionIndex}_${questionIndex}`;
            return [
              { id: `${key}_t1`, title: `${key} (T1)` },
              { id: `${key}_t2`, title: `${key} (T2)` },
              { id: `${key}_t3`, title: `${key} (T3)` },
            ];
          })
        )
        .filter(Boolean),
    ],
  });

  const records = await Promise.all(
    users.map(async (userDoc) => {
      const codeDoc = await Code.findOne({ _id: userDoc.userId });
      const record = {
        userId: userDoc.userId,
        userCode: codeDoc ? codeDoc.code : "Unknown",
        gender: userDoc.data?.q0_0 || "",
        birthYear: userDoc.data?.q0_1 || "",

        t1: userDoc.timeStamps?.t1
          ? new Date(userDoc.timeStamps.t1).toLocaleString()
          : "",
        t2: userDoc.timeStamps?.t2
          ? new Date(userDoc.timeStamps.t2).toLocaleString()
          : "",
        t3: userDoc.timeStamps?.t3
          ? new Date(userDoc.timeStamps.t3).toLocaleString()
          : "",
        courses: userDoc.courses?.join(", ") || "",
        courseFeedback:
          userDoc.openEndedResponses?.attempt2_course_feedback || "",
        strategy: userDoc.openEndedResponses?.t1_strategy || "",
        reflection: userDoc.openEndedResponses?.t2_reflection || "",
        attemptNumber: userDoc.attemptNumber || 1,
      };

      surveyData.forEach((section, sectionIndex) => {
        if (sectionIndex === 0) return; // skip personal info for clarity
        section.questions.forEach((question, qIndex) => {
          const key = `q${sectionIndex}_${qIndex}`;
          // T1
          record[`${key}_t1`] = userDoc.initialResponses?.[key] || "";
          // T2
          record[`${key}_t2`] = userDoc.updatedResponses?.[key] || "";
          // T3
          record[`${key}_t3`] = userDoc.followUpResponses?.[key] || "";
        });
      });

      return record;
    })
  );

  try {
    await csvWriter.writeRecords(records);
    console.log(`CSV file updated successfully with ${records.length} records`);
  } catch (err) {
    console.error("Error updating CSV file:", err);
    throw new Error(`Failed to write CSV file: ${err.message}`);
  }
}

/* Reset user data. Keeps T1 data, resets T2/T3. */
app.post("/api/reset-user-data", async (req, res) => {
  const { userId } = req.body;
  if (!userId) {
    return res.status(400).json({ message: "userId is required." });
  }
  try {
    const user = await UserData.findOne({ userId });
    if (!user) {
      return res.status(404).json({ message: "User not found." });
    }

    // Keep T1 subset
    const t1Subset = {
      q0_0: user.data.q0_0,
      q0_1: user.data.q0_1,
      q0_2: user.data.q0_2,
      q0_3: user.data.q0_3,
      q0_4: user.data.q0_4,
      q0_5: user.data.q0_5,
      q0_6: user.data.q0_6,
    };

    user.data = t1Subset;
    user.updatedResponses = {};
    user.updatedScores = {};
    user.followUpResponses = {};
    user.followUpScores = {};
    user.isComplete = false;
    user.currentSection = 0;
    await user.save();

    res.status(200).json({ message: "Survey data reset successfully." });
  } catch (err) {
    console.error("Error resetting user data:", err);
    res.status(500).json({ message: "Error resetting user data." });
  }
});

/* Register a new code. */
app.post("/register", async (req, res) => {
  const { code } = req.body;
  if (!code) {
    return res.status(400).json({ message: "Code is required" });
  }
  try {
    const existingCode = await Code.findOne({ code });
    if (existingCode) {
      return res.status(400).json({
        message:
          "Dieser Code existiert bereits. Bitte verwenden Sie stattdessen die Initialen Ihres Vaters für den zweiten Teil des Codes.",
        isDuplicateCode: true,
      });
    }
    const newCode = new Code({ code });
    await newCode.save();
    res.status(201).json({ message: "Code saved", userId: newCode._id });
  } catch (err) {
    console.error("Failed to save code:", err);
    res.status(500).json({ message: "Error saving code: " + err.message });
  }
});

/* Login endpoint supports T1/T2/T3 logic via attemptType. */
app.post("/login", async (req, res) => {
  const { code, courses, startNewAttempt, attemptType } = req.body;
  try {
    const codeDoc = await Code.findOne({ code: code.toUpperCase() });
    if (!codeDoc) {
      return res.status(400).json({ message: "Ungültiger Code" });
    }
    let user = await UserData.findOne({ userId: codeDoc._id });

    if (user) {
      if (startNewAttempt) {
        if (attemptType === "T2") {
          user.attemptNumber = 2;
          user.currentSection = 0;
          user.updatedResponses = {};
          user.updatedScores = {};
          user.openEndedResponses = {};
          user.followUpResponses = {};
          user.followUpScores = {};
          user.courses = courses ? courses.split(",") : [];
        } else if (attemptType === "T3") {
          user.attemptNumber = 3;
          user.currentSection = 0;
          user.followUpResponses = {};
          user.followUpScores = {};
          user.openEndedResponses = {};
          // If you want to keep T2 data, you can keep user.updatedResponses / updatedScores as is,
          // or reset them if needed. It's your choice for T3 logic.
          user.courses = courses ? courses.split(",") : [];
        } else {
          // Reset fully to T1
          user.attemptNumber = 1;
          user.currentSection = 0;
          user.data = {};
          user.initialResponses = {};
          user.updatedResponses = {};
          user.followUpResponses = {};
          user.initialScores = {};
          user.updatedScores = {};
          user.followUpScores = {};
          user.openEndedResponses = {};
          user.courses = courses ? courses.split(",") : [];
        }
        await user.save();
      } else {
        // continuing same attempt
        user.latestSubmissionTime = new Date();
        await user.save();
      }
    } else {
      // New user
      user = new UserData({
        userId: codeDoc._id,
        data: {},
        courses: courses ? [courses] : [],
        isComplete: false,
        timeStamps: {
          t1: {
            type: Date,
            default: null,
          },
          t2: {
            type: Date,
            default: null,
          },
          t3: {
            type: Date,
            default: null,
          },
        },
        initialScores: {},
        updatedScores: {},
        followUpScores: {},
        initialResponses: {},
        updatedResponses: {},
        followUpResponses: {},
        currentSection: 0,
        datenschutzConsent: false,
        unterschrift: "",
        attemptNumber: 1,
        openEndedResponses: {},
      });
      await user.save();
    }

    res.status(200).json({
      message: "Login erfolgreich",
      userId: codeDoc._id,
      isComplete: user.isComplete || false,
      currentSection: user.currentSection || 0,
      startNewAttempt: startNewAttempt || false,
      attemptNumber: user.attemptNumber || 1,
    });
  } catch (err) {
    console.error("Fehler beim Login:", err);
    res.status(500).json({
      message: "Fehler bei der Verarbeitung der Login-Anfrage",
      error: err.message,
    });
  }
});

/* Example of generating recommendations. Now handles T3 specifically. */
app.post("/api/get-recommendations", async (req, res) => {
  const { userId } = req.body;
  try {
    const user = await UserData.findOne({ userId });
    if (!user) {
      return res.status(404).json({ error: "User not found" });
    }

    let scoresToUse;
    if (user.attemptNumber === 3) {
      scoresToUse = user.followUpScores;
    } else if (user.attemptNumber === 2) {
      scoresToUse = user.updatedScores;
    } else {
      scoresToUse = user.initialScores;
    }

    const recommendations = Object.entries(scoresToUse).map(
      ([category, score]) => ({
        category,
        score,
        courseLink: `https://ilias.uni-rostock.de/${category}/${Math.floor(
          score / 25
        )}`,
      })
    );
    res.json({ recommendations });
  } catch (err) {
    console.error("Recommendation error:", err);
    res.status(500).json({ error: "Failed to generate recommendations" });
  }
});

/* Save user data for T1/T2/T3. */
app.post("/api/save-user-data", async (req, res) => {
  try {
    const {
      userId,
      data,
      isComplete,
      categoryScores,
      currentSection,
      datenschutzConsent,
      unterschrift,
      openEndedResponses,
      personalInfo,
      isPersonalInfo,
    } = req.body;

    if (!userId) {
      return res.status(400).json({
        message: "Missing userId in request body.",
        success: false,
      });
    }

    let user = await UserData.findOne({ userId });
    const now = new Date();

    if (!user) {
      user = new UserData({
        userId,
        data: isPersonalInfo ? personalInfo : {},
        courses: [],
        isComplete: false,
        "timeStamps.t1": now,
        "timeStamps.t2": now,
        "timeStamps.t3": now,
        initialScores: {},
        updatedScores: {},
        followUpScores: {},
        initialResponses: {},
        updatedResponses: {},
        followUpResponses: {},
        currentSection: 0,
        datenschutzConsent: false,
        unterschrift: "",
        attemptNumber: 1,
        openEndedResponses: {},
      });
    } else {
      user.latestSubmissionTime = now;
      // If the call includes personal info vs normal question responses
      if (isPersonalInfo && personalInfo) {
        user.data = { ...user.data, ...personalInfo };
      } else if (data) {
        user.data = { ...user.data, ...data };
      }
    }

    if (currentSection !== undefined) {
      user.currentSection = currentSection;
    }

    if (isComplete) {
      user.isComplete = true;
    }

    if (datenschutzConsent !== undefined) {
      user.datenschutzConsent = datenschutzConsent;
    }
    if (unterschrift) {
      user.unterschrift = unterschrift;
    }
    if (openEndedResponses) {
      user.openEndedResponses = {
        ...user.openEndedResponses,
        ...openEndedResponses,
      };
    }

    // If user completes T1, T2, or T3:
    // T1 => store in initialScores
    // T2 => store in updatedScores
    // T3 => store in followUpScores
    if (isComplete) {
      if (user.attemptNumber === 1 && !Object.keys(user.initialScores).length) {
        const calcResult = calculateCategoryScores(
          { initialResponses: data, attemptNumber: 1 },
          surveyData
        );
        user.initialScores = calcResult.t1;
        user.initialResponses = { ...data };
      } else if (user.attemptNumber === 2) {
        const calcResult = calculateCategoryScores(
          {
            initialResponses: user.initialResponses,
            updatedResponses: data,
            attemptNumber: user.attemptNumber,
          },
          surveyData
        );
        user.updatedScores = calcResult.latest;
        user.updatedResponses = { ...data };
      } else if (user.attemptNumber === 3) {
        // For T3, we leverage followUpScores and followUpResponses
        const calcResult = calculateCategoryScores(
          {
            initialResponses: user.initialResponses,
            updatedResponses: data, // We treat "updatedResponses" field in the calculation logic
            attemptNumber: user.attemptNumber,
          },
          surveyData
        );
        user.followUpScores = calcResult.latest;
        user.followUpResponses = { ...data };
      }
    }

    await user.save();
    return res.status(200).json({
      message: "User data saved successfully.",
      success: true,
      initialScores: user.initialScores,
      updatedScores: user.updatedScores,
      followUpScores: user.followUpScores || {},
      isComplete: user.isComplete,
      openEndedResponses: user.openEndedResponses,
      attemptNumber: user.attemptNumber,
    });
  } catch (error) {
    console.error("Error saving user data:", error); // <== Check this in the server logs!
    return res.status(500).json({
      message: "Error saving user data",
      details: error.message,
      success: false,
    });
  }
});

/* Fetch user data. */
app.get("/api/user-data/:userId", async (req, res) => {
  const { userId } = req.params;
  try {
    const user = await UserData.findOne({ userId });
    if (!user) {
      return res.status(404).json({ message: "User data not found" });
    }
    return res.status(200).json({
      data: user.data,
      courses: user.courses,
      isComplete: user.isComplete,
      initialScores: user.initialScores,
      updatedScores: user.updatedScores,
      followUpScores: user.followUpScores,
      initialResponses: user.initialResponses,
      updatedResponses: user.updatedResponses,
      followUpResponses: user.followUpResponses,
      currentSection: user.currentSection || 0,
      datenschutzConsent: user.datenschutzConsent,
      unterschrift: user.unterschrift || "",
      attemptNumber: user.attemptNumber || 1,
    });
  } catch (err) {
    console.error("Error fetching user data:", err);
    res.status(500).json({ message: "Error fetching user data" });
  }
});

/* Dashboard login endpoint. */
app.post("/api/dashboard-login", (req, res) => {
  const { userId, password } = req.body;
  if (userId === DASHBOARD_USER_ID && password === DASHBOARD_PASSWORD) {
    const token = jwt.sign({ userId }, JWT_SECRET, { expiresIn: "1h" });
    res.json({ token });
  } else {
    res.status(401).json({ error: "Invalid credentials" });
  }
});

/* Serve the dashboard pages. */
app.get("/dashboard", (req, res) => {
  res.sendFile(path.resolve(__dirname, "docs", "dashboard.html"));
});

app.get("/dashboard-login", (req, res) => {
  res.sendFile(path.resolve(__dirname, "docs", "dashboard-login.html"));
});

/* Dashboard data (requires authentication). */
app.get("/api/dashboard-data", authenticate, async (req, res) => {
  try {
    const allUsers = await UserData.find().lean();
    // Example questionIds for your survey
    const questionIds = [
      "q0_0",
      "q0_1",
      "q1_0",
      "q1_1",
      "q1_2",
      "q1_3",
      "q1_4",
      "q1_5",
      "q2_0",
      "q2_1",
      "q2_2",
      "q2_3",
      "q2_4",
      "q2_5",
      "q2_6",
      "q3_0",
      "q3_1",
      "q3_2",
      "q3_3",
      "q3_4",
      "q3_5",
      "q3_6",
      "q4_0",
      "q4_1",
      "q4_2",
      "q4_3",
      "q4_4",
      "q4_5",
      "q5_0",
      "q5_1",
      "q5_2",
      "q5_3",
      "q5_4",
      "q5_5",
      "q5_6",
      "q6_0",
      "q6_1",
      "q6_2",
      "q6_3",
      "q6_4",
      "q6_5",
    ];

    const sections = surveyData
      .map((section) => section.title)
      .filter(
        (title) => title !== "Persönliche Angaben" && title !== "Abschluss"
      );

    const users = await Promise.all(
      allUsers.map(async (userDoc) => {
        const codeDoc = await Code.findOne({ _id: userDoc.userId });
        const userData = userDoc.data || {};
        const formatted = {};

        // For T1, T2, T3 we store them separately if we want.
        // Example: qX_Y_t1, qX_Y_t2, qX_Y_t3
        questionIds
          .filter(
            (q) =>
              q.startsWith("q") &&
              q !== "q0_0" &&
              q !== "q0_1" &&
              q !== "q0_2" &&
              q !== "q0_3"
          )
          .forEach((qid) => {
            formatted[`${qid}_t1`] = userDoc.initialResponses?.[qid] || "";
            formatted[`${qid}_t2`] = userDoc.updatedResponses?.[qid] || "";
            formatted[`${qid}_t3`] = userDoc.followUpResponses?.[qid] || "";
          });

        return {
          userId: userDoc.userId,
          userCode: codeDoc ? codeDoc.code : "Unknown",
          gender: userData.q0_0 || "",
          birthYear: userData.q0_1 || "",
          t1: userDoc.timeStamps?.t1
            ? new Date(userDoc.timeStamps.t1).toLocaleString()
            : "",
          t2: userDoc.timeStamps?.t2
            ? new Date(userDoc.timeStamps.t2).toLocaleString()
            : "",
          t3: userDoc.timeStamps?.t3
            ? new Date(userDoc.timeStamps.t3).toLocaleString()
            : "",
          data: {
            responses: userData,
            formattedResponses: formatted,
            openEndedResponses: userDoc.openEndedResponses || {},
            strategy: userDoc.openEndedResponses?.t1_strategy || "",
          },
          isComplete: userDoc.isComplete || false,
          courses: userDoc.courses || [],
          initialScores: userDoc.initialScores || {},
          updatedScores: userDoc.updatedScores || {},
          followUpScores: userDoc.followUpScores || {},
          initialResponses: userDoc.initialResponses || {},
          updatedResponses: userDoc.updatedResponses || {},
          followUpResponses: userDoc.followUpResponses || {},
          datenschutzConsent: userDoc.datenschutzConsent,
          unterschrift: userDoc.unterschrift || "",
          openEndedResponses: userDoc.openEndedResponses || {},
          strategieAuswahl: userDoc.openEndedResponses?.t1_strategy || "",
          veraenderungKompetenz:
            userDoc.openEndedResponses?.t2_reflection || "",
          attemptNumber: userDoc.attemptNumber || 1,
          questionResponses: {
            t1: userDoc.initialResponses || {},
            t2: userDoc.updatedResponses || {},
            t3: userDoc.followUpResponses || {},
          },
        };
      })
    );

    const metadata = {
      format: {
        t1: "Initial responses from first attempt",
        t2: "Responses from second attempt (T2)",
        t3: "Responses from third attempt (T3)",
      },
      questionCount: questionIds.filter(
        (q) =>
          q.startsWith("q") &&
          q !== "q0_0" &&
          q !== "q0_1" &&
          q !== "q0_2" &&
          q !== "q0_3"
      ).length,
    };

    res.json({ users, sections, metadata, questionIds });
  } catch (err) {
    console.error("Error fetching dashboard data:", err);
    res.status(500).json({
      error: "Error fetching dashboard data",
      details: err.message,
    });
  }
});

/* Fallback route to serve the main index. */
app.get("*", (req, res) => {
  res.sendFile(path.resolve(__dirname, "docs", "index.html"));
});

/* Endpoint to save open-ended responses in openEndedResponses object. */
app.post("/api/save-open-ended-response", async (req, res) => {
  const { userId, key, response } = req.body;
  if (!userId || !response || !key) {
    return res.status(400).json({
      message: "Missing userId, response, or key in request body.",
    });
  }
  try {
    const objectId = new mongoose.Types.ObjectId(userId);
    let user = await UserData.findOne({ userId: objectId });
    if (!user) {
      return res.status(404).json({ message: "User data not found." });
    }
    if (!user.openEndedResponses) {
      user.openEndedResponses = {};
    }
    user.openEndedResponses[key] = response;
    await user.save();

    res.status(200).json({
      message: "Open-ended response saved successfully.",
    });
  } catch (err) {
    console.error("Error saving open-ended response:", err);
    res.status(500).json({
      message: "Error saving open-ended response",
      details: err.message,
    });
  }
});

// Check if user has completed T1, so we can allow them to view results:
app.post("/api/check-results", async (req, res) => {
  try {
    const { code } = req.body;
    if (!code) {
      return res.status(400).json({ success: false, message: "Code is required" });
    }
    const codeDoc = await Code.findOne({ code: code.toUpperCase() });
    if (!codeDoc) {
      return res.status(404).json({ success: false, message: "Ungültiger Code" });
    }
    const user = await UserData.findOne({ userId: codeDoc._id });
    if (!user) {
      return res.status(404).json({ success: false, message: "User not found for this code" });
    }
    const hasT1Data = user.initialScores && Object.keys(user.initialScores).length > 0;
    if (!hasT1Data) {
      return res.status(200).json({
        success: false,
        message: "Sie haben den ersten Teil (T1) noch nicht abgeschlossen. Bitte füllen Sie zunächst T1 aus.",
      });
    }
    return res.status(200).json({ success: true, userId: user.userId });
  } catch (err) {
    console.error("Error checking results:", err);
    res.status(500).json({ success: false, message: "Server error checking results" });
  }
});

// Serve the new results page
app.get("/results", (req, res) => {
  res.sendFile(path.resolve(__dirname, "docs", "results.html"));
});


/* Start the server. */
const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
