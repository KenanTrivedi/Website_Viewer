require("dotenv").config();
const express = require("express");
const createCsvWriter = require("csv-writer").createObjectCsvWriter;
const mongoose = require("mongoose");
const bodyParser = require("body-parser");
const path = require("path");
const jwt = require("jsonwebtoken");
const app = express();

mongoose.set("strictQuery", false);
app.use(bodyParser.json());
app.use(express.static("docs"));

// --------------------------------------------------------------------
// Connect to MongoDB
const mongoURI =
  process.env.MONGODB_URI || "mongodb://localhost:27017/surveyDB";
mongoose
  .connect(mongoURI)
  .then(() => console.log("MongoDB connected"))
  .catch((err) => console.error("MongoDB connection error:", err));

// --------------------------------------------------------------------
// CODE SCHEMA
const codeSchema = new mongoose.Schema({ code: String });
const Code = mongoose.model("Code", codeSchema, "codes");

// --------------------------------------------------------------------
// USERDATA SCHEMA  (userId is a STRING, unique)
const userDataSchema = new mongoose.Schema({
  userId: { type: String, required: true, unique: true },
  data: { type: Object, default: {} },
  courses: { type: [String], default: [] },
  isComplete: { type: Boolean, default: false },
  timeStamps: {
    t1: { type: Date, default: null },
    t2: { type: Date, default: null },
    t3: { type: Date, default: null },
  },
  initialScores: { type: Object, default: {} },
  updatedScores: { type: Object, default: {} },
  followUpScores: { type: Object, default: {} },
  initialResponses: { type: Object, default: {} },
  updatedResponses: { type: Object, default: {} },
  followUpResponses: { type: Object, default: {} },
  currentSection: { type: Number, default: 0 },
  datenschutzConsent: { type: Boolean, default: false },
  unterschrift: { type: String, default: "" },
  attemptNumber: { type: Number, default: 1 },
  openEndedResponses: { type: Object, default: {} },
});
const UserData = mongoose.model("UserData", userDataSchema, "userdatas");

// --------------------------------------------------------------------
// Admin login constants
const JWT_SECRET = process.env.JWT_SECRET || "your-secret-key";
const DASHBOARD_USER_ID = process.env.DASHBOARD_USER_ID || "admin";
const DASHBOARD_PASSWORD = process.env.DASHBOARD_PASSWORD || "password";

// --------------------------------------------------------------------
// Load the surveyData
const surveyData = require("./docs/js/survey-data.min.js");

// --------------------------------------------------------------------
// A simple helper for protecting dashboard routes
function authenticate(req, res, next) {
  const authHeader = req.headers.authorization;
  const token = authHeader?.split(" ")[1];
  if (!token) {
    return res.status(401).json({ error: "Unauthorized" });
  }
  jwt.verify(token, JWT_SECRET, (err, decoded) => {
    if (err) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    req.userId = decoded.userId;
    next();
  });
}

// --------------------------------------------------------------------
// Simple function to calculate T1 vs T2/T3 scale scores
function calculateCategoryScores(user, survey) {
  const result = { t1: {}, latest: {} };

  survey.forEach((section, sIndex) => {
    // skip personal info
    if (
      section.title !== "Persönliche Angaben" &&
      section.title !== "Abschluss"
    ) {
      let sumT1 = 0;
      let sumLatest = 0;
      let questionCount = 0;

      section.questions.forEach((question, qIndex) => {
        if (question.type === "scale") {
          questionCount++;
          const key = `q${sIndex}_${qIndex}`;

          if (user.initialResponses?.[key]) {
            const valT1 = parseInt(user.initialResponses[key], 10);
            if (!isNaN(valT1)) sumT1 += valT1;
          }
          if (user.updatedResponses?.[key]) {
            const val2 = parseInt(user.updatedResponses[key], 10);
            if (!isNaN(val2)) sumLatest += val2;
          }
        }
      });

      if (questionCount > 0) {
        const max = 6 * questionCount; // scale 0..6
        result.t1[section.title] = Math.round((sumT1 / max) * 100);
        result.latest[section.title] = Math.round((sumLatest / max) * 100);
      }
    }
  });

  // compute average
  function avg(scoresObj) {
    const vals = Object.values(scoresObj);
    if (!vals.length) return 0;
    return Math.round(vals.reduce((a, b) => a + b, 0) / vals.length);
  }
  result.t1.overall = avg(result.t1);
  result.latest.overall = avg(result.latest);

  result.metadata = {
    maxScorePerQuestion: 6,
    scoreType: "percentage",
    categories: Object.keys(result.t1).filter((c) => c !== "overall"),
    t1Label: "Initial Assessment",
    latestLabel: `Attempt ${user.attemptNumber || 1}`,
  };
  return result;
}

// --------------------------------------------------------------------
// 1)  Reset user data except T1
app.post("/api/reset-user-data", async (req, res) => {
  const { userId } = req.body;
  if (!userId) {
    return res.status(400).json({ message: "userId is required." });
  }
  try {
    const user = await UserData.findOne({ userId });
    if (!user) {
      return res.status(404).json({ message: "User not found." });
    }
    // Keep only T1 subset
    const t1Subset = {
      q0_0: user.data.q0_0,
      q0_1: user.data.q0_1,
      q0_2: user.data.q0_2,
      q0_3: user.data.q0_3,
      q0_4: user.data.q0_4,
      q0_5: user.data.q0_5,
      q0_6: user.data.q0_6,
    };
    user.data = t1Subset;
    user.updatedResponses = {};
    user.updatedScores = {};
    user.followUpResponses = {};
    user.followUpScores = {};
    user.isComplete = false;
    user.currentSection = 0;
    await user.save();
    return res.status(200).json({ message: "Survey data reset successfully." });
  } catch (err) {
    console.error("Error resetting user data:", err);
    return res.status(500).json({ message: "Error resetting user data." });
  }
});

// --------------------------------------------------------------------
// 2)  Register a new code
app.post("/register", async (req, res) => {
  const { code } = req.body;
  if (!code) {
    return res.status(400).json({ message: "Code is required" });
  }
  try {
    const uppercaseCode = code.toUpperCase();
    const existingCode = await Code.findOne({ code: uppercaseCode });
    if (existingCode) {
      return res.status(400).json({
        message:
          "Dieser Code existiert bereits. Bitte verwenden Sie einen anderen Code.",
        isDuplicateCode: true,
      });
    }
    const newCode = new Code({ code: uppercaseCode });
    await newCode.save();

    return res.status(201).json({ message: "Code saved", userId: newCode._id });
  } catch (err) {
    console.error("Failed to save code:", err);
    return res
      .status(500)
      .json({ message: "Error saving code: " + err.message });
  }
});

// --------------------------------------------------------------------
// 3)  LOGIN with T1/T2/T3 logic (CREATES doc if not found)
app.post("/login", async (req, res) => {
  const { code, courses, startNewAttempt, attemptType } = req.body;
  try {
    const uppercaseCode = code.toUpperCase();
    const codeDoc = await Code.findOne({ code: uppercaseCode });
    if (!codeDoc) {
      return res.status(400).json({ message: "Ungültiger Code" });
    }
    const stringUserId = codeDoc._id.toString();
    let user = await UserData.findOne({ userId: stringUserId });

    if (user) {
      // doc already exists
      if (startNewAttempt) {
        // they want T2 or T3 or reset T1
        if (attemptType === "T2") {
          user.attemptNumber = 2;
          user.currentSection = 0;
          user.updatedResponses = {};
          user.updatedScores = {};
          user.followUpResponses = {};
          user.followUpScores = {};
          user.openEndedResponses = {};
          user.courses = courses ? courses.split(",") : [];
        } else if (attemptType === "T3") {
          user.attemptNumber = 3;
          user.currentSection = 0;
          user.followUpResponses = {};
          user.followUpScores = {};
          user.openEndedResponses = {};
          user.courses = courses ? courses.split(",") : [];
        } else {
          // reset T1
          user.attemptNumber = 1;
          user.currentSection = 0;
          user.data = {};
          user.initialResponses = {};
          user.updatedResponses = {};
          user.followUpResponses = {};
          user.initialScores = {};
          user.updatedScores = {};
          user.followUpScores = {};
          user.openEndedResponses = {};
          user.courses = courses ? courses.split(",") : [];
        }
        await user.save();
      } else {
        // continuing same attempt
        user.latestSubmissionTime = new Date();
        await user.save();
      }
    } else {
      // doc does NOT exist => create
      user = new UserData({
        userId: stringUserId,
        data: {},
        courses: courses ? [courses] : [],
        isComplete: false,
        timeStamps: { t1: null, t2: null, t3: null },
        initialScores: {},
        updatedScores: {},
        followUpScores: {},
        initialResponses: {},
        updatedResponses: {},
        followUpResponses: {},
        currentSection: 0,
        datenschutzConsent: false,
        unterschrift: "",
        attemptNumber: 1,
        openEndedResponses: {},
      });
      await user.save();
    }

    return res.status(200).json({
      message: "Login erfolgreich",
      userId: stringUserId,
      isComplete: user.isComplete || false,
      currentSection: user.currentSection || 0,
      startNewAttempt: !!startNewAttempt,
      attemptNumber: user.attemptNumber || 1,
    });
  } catch (err) {
    console.error("Fehler beim Login:", err);
    return res.status(500).json({
      message: "Fehler bei der Verarbeitung der Login-Anfrage",
      error: err.message,
    });
  }
});

// --------------------------------------------------------------------
// 4)  Save user data for T1/T2/T3 (NO doc creation if not found)
app.post("/api/save-user-data", async (req, res) => {
  try {
    const {
      userId,
      data,
      isComplete,
      currentSection,
      datenschutzConsent,
      unterschrift,
      openEndedResponses,
      personalInfo,
      isPersonalInfo,
      attemptNumber,
    } = req.body;

    if (!userId) {
      return res.status(400).json({
        message: "Missing userId in request body.",
        success: false,
      });
    }

    let user = await UserData.findOne({ userId });
    if (!user) {
      // do NOT create doc here; user must have logged in
      return res.status(400).json({
        message: "No existing user doc. Please log in or refresh first.",
      });
    }

    // We have user doc, so proceed
    const now = new Date();
    user.latestSubmissionTime = now;
    if (attemptNumber) {
      user.attemptNumber = attemptNumber;
    }

    // Merge personal info
    if (isPersonalInfo && personalInfo) {
      user.data = { ...user.data, ...personalInfo };
    } else if (data) {
      user.data = { ...user.data, ...data };
    }

    if (currentSection !== undefined) {
      user.currentSection = currentSection;
    }
    if (datenschutzConsent !== undefined) {
      user.datenschutzConsent = datenschutzConsent;
    }
    if (unterschrift) {
      user.unterschrift = unterschrift;
    }
    if (openEndedResponses) {
      user.openEndedResponses = {
        ...user.openEndedResponses,
        ...openEndedResponses,
      };
    }

    // If not finished, partial storing
    if (!isComplete) {
      if (user.attemptNumber === 1) {
        user.initialResponses = {
          ...user.initialResponses,
          ...data,
        };
      } else if (user.attemptNumber === 2) {
        user.updatedResponses = {
          ...user.updatedResponses,
          ...data,
        };
      } else if (user.attemptNumber === 3) {
        user.followUpResponses = {
          ...user.followUpResponses,
          ...data,
        };
      }
    }

    // If finishing attempt
    if (isComplete) {
      user.isComplete = true;
      if (user.attemptNumber === 1) {
        user.initialResponses = { ...user.initialResponses, ...data };
        const calcResult = calculateCategoryScores(
          { initialResponses: user.initialResponses, attemptNumber: 1 },
          surveyData
        );
        user.initialScores = calcResult.t1;
      } else if (user.attemptNumber === 2) {
        user.updatedResponses = { ...user.updatedResponses, ...data };
        const calcResult = calculateCategoryScores(
          {
            initialResponses: user.initialResponses,
            updatedResponses: user.updatedResponses,
            attemptNumber: 2,
          },
          surveyData
        );
        user.updatedScores = calcResult.latest;
      } else if (user.attemptNumber === 3) {
        user.followUpResponses = { ...user.followUpResponses, ...data };
        const calcResult = calculateCategoryScores(
          {
            initialResponses: user.initialResponses,
            updatedResponses: user.updatedResponses,
            followUpResponses: user.followUpResponses,
            attemptNumber: 3,
          },
          surveyData
        );
        user.followUpScores = calcResult.latest;
      }
    }

    await user.save();
    return res.status(200).json({
      message: "User data saved successfully.",
      success: true,
      attemptNumber: user.attemptNumber,
      isComplete: user.isComplete,
      initialScores: user.initialScores,
      updatedScores: user.updatedScores,
      followUpScores: user.followUpScores,
      openEndedResponses: user.openEndedResponses,
    });
  } catch (err) {
    console.error("Error saving user data:", err);
    return res.status(500).json({
      message: "Error saving user data",
      details: err.message,
      success: false,
    });
  }
});

// --------------------------------------------------------------------
// 5)  Return user data. If doc not found, return an EMPTY doc (not 404)
app.get("/api/user-data/:userId", async (req, res) => {
  const { userId } = req.params;
  try {
    const user = await UserData.findOne({ userId });
    if (!user) {
      // Instead of 404, return a default doc so there's no console error:
      return res.status(200).json({
        data: {},
        courses: [],
        isComplete: false,
        initialScores: {},
        updatedScores: {},
        followUpScores: {},
        initialResponses: {},
        updatedResponses: {},
        followUpResponses: {},
        currentSection: -1,
        datenschutzConsent: false,
        unterschrift: "",
        attemptNumber: 1,
        openEndedResponses: {},
      });
    }
    return res.status(200).json({
      data: user.data,
      courses: user.courses,
      isComplete: user.isComplete,
      initialScores: user.initialScores,
      updatedScores: user.updatedScores,
      followUpScores: user.followUpScores,
      initialResponses: user.initialResponses,
      updatedResponses: user.updatedResponses,
      followUpResponses: user.followUpResponses,
      currentSection: user.currentSection || 0,
      datenschutzConsent: user.datenschutzConsent,
      unterschrift: user.unterschrift || "",
      attemptNumber: user.attemptNumber || 1,
      openEndedResponses: user.openEndedResponses || {},
    });
  } catch (err) {
    console.error("Error fetching user data:", err);
    return res.status(500).json({ message: "Error fetching user data" });
  }
});

// --------------------------------------------------------------------
// Dashboard login
app.post("/api/dashboard-login", (req, res) => {
  const { userId, password } = req.body;
  if (userId === DASHBOARD_USER_ID && password === DASHBOARD_PASSWORD) {
    const token = jwt.sign({ userId }, JWT_SECRET, { expiresIn: "1h" });
    res.json({ token });
  } else {
    res.status(401).json({ error: "Invalid credentials" });
  }
});

// --------------------------------------------------------------------
// Serve the dashboard
app.get("/dashboard", (req, res) => {
  res.sendFile(path.resolve(__dirname, "docs", "dashboard.html"));
});
app.get("/dashboard-login", (req, res) => {
  res.sendFile(path.resolve(__dirname, "docs", "dashboard-login.html"));
});

// --------------------------------------------------------------------
// 6) Provide dashboard data route
app.get("/api/dashboard-data", authenticate, async (req, res) => {
  try {
    // Example question IDs for scale questions (excluding personal info = index 0):
    // Adjust these as needed if your survey changed
    const questionIds = [];
    surveyData.forEach((section, sIndex) => {
      if (sIndex === 0) return; // skip "Persönliche Angaben"
      section.questions.forEach((q, qIndex) => {
        const key = `q${sIndex}_${qIndex}`;
        questionIds.push(key);
      });
    });

    // Gather all user documents
    const allUsers = await UserData.find().lean();
    const users = [];

    for (const doc of allUsers) {
      // find the code for this doc
      const codeDoc = await Code.findOne({ _id: doc.userId });
      const userCode = codeDoc ? codeDoc.code : "Unknown";

      // Build a minimal data object
      const personalData = {
        // Possibly retrieve "q0_0" (gender?), "q0_1" (year?), etc.
        q0_0: doc.data?.q0_0 || doc.initialResponses?.q0_0 || "",
        q0_1: doc.data?.q0_1 || doc.initialResponses?.q0_1 || "",
        q0_2: doc.data?.q0_2 || doc.initialResponses?.q0_2 || "",
        q0_3: doc.data?.q0_3 || doc.initialResponses?.q0_3 || "",
        q0_4: doc.data?.q0_4 || doc.initialResponses?.q0_4 || "",
        q0_5: doc.data?.q0_5 || doc.initialResponses?.q0_5 || "",
        q0_6: doc.data?.q0_6 || doc.initialResponses?.q0_6 || "",
      };

      // Compose result for one user
      users.push({
        userId: doc.userId,
        userCode,
        data: personalData,
        attemptNumber: doc.attemptNumber || 1,
        isComplete: doc.isComplete || false,
        timeStamps: {
          t1: doc.timeStamps?.t1 ? doc.timeStamps.t1.toISOString() : null,
          t2: doc.timeStamps?.t2 ? doc.timeStamps.t2.toISOString() : null,
          t3: doc.timeStamps?.t3 ? doc.timeStamps.t3.toISOString() : null,
        },
        courses: doc.courses || [],
        initialScores: doc.initialScores || {},
        updatedScores: doc.updatedScores || {},
        followUpScores: doc.followUpScores || {},
        initialResponses: doc.initialResponses || {},
        updatedResponses: doc.updatedResponses || {},
        followUpResponses: doc.followUpResponses || {},
        openEndedResponses: doc.openEndedResponses || {},
        datenschutzConsent: doc.datenschutzConsent,
        unterschrift: doc.unterschrift || "",
        currentSection: doc.currentSection || 0,
      });
    }

    return res.json({ users, questionIds });
  } catch (err) {
    console.error("Error fetching dashboard data:", err);
    return res.status(500).json({
      error: "Error fetching dashboard data",
      details: err.message,
    });
  }
});

// --------------------------------------------------------------------
// Fallback route: serve main index
app.get("*", (req, res) => {
  res.sendFile(path.resolve(__dirname, "docs", "index.html"));
});

// --------------------------------------------------------------------
// Endpoint to save open-ended with userId as string
app.post("/api/save-open-ended-response", async (req, res) => {
  const { userId, key, response } = req.body;
  if (!userId || !response || !key) {
    return res
      .status(400)
      .json({ message: "Missing userId, response, or key in request body." });
  }
  try {
    let user = await UserData.findOne({ userId });
    if (!user) {
      return res.status(404).json({ message: "User data not found." });
    }
    user.openEndedResponses = user.openEndedResponses || {};
    user.openEndedResponses[key] = response;
    await user.save();
    return res
      .status(200)
      .json({ message: "Open-ended response saved successfully." });
  } catch (err) {
    console.error("Error saving open-ended response:", err);
    return res.status(500).json({
      message: "Error saving open-ended response",
      details: err.message,
    });
  }
});

// --------------------------------------------------------------------
// Start server
const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
